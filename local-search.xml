<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络笔记-第二章</title>
    <link href="/2022/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2022/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929153906.png"></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>⚡写了第一章的笔记以后发现如果所有的笔记都写的话工作量有点大，所以从第二章开始就只记录一些重点的以及不熟悉的知识点啦，并不会全部记录~好伐啦让我们一起进入计算机网络-第二章🔥    </p><h1 id="二、应用层协议原理"><a href="#二、应用层协议原理" class="headerlink" title="二、应用层协议原理"></a>二、应用层协议原理</h1><ul><li><p>网络应用的体系结构</p><ul><li>客户-服务器模式（C/S模式）<ul><li>服务器<ul><li>一直运行</li><li>固定的IP地址和周知的端口号（约定）</li><li>扩展性：服务器场——数据中心进行扩展且扩展性差</li></ul></li><li>客户端<ul><li>主动与服务器通信</li><li>与互联网有间接性的连接</li><li>可能是动态IP地址</li><li>不直接与其他客户端通信</li></ul></li></ul></li><li>对等体（P2P)体系结构<ul><li>（几乎）没有一直运行的服务器</li><li>任意端系统之间可以进行通信</li><li>每一个节点既是客户端又是服务器<ul><li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li></ul></li><li>参与的主机间歇性连接且可以改变IP地址</li><li>例子：迅雷</li></ul></li><li>C/S 和 P2P体系结构的混合体<ul><li>Napster<ul><li>文件搜索：集中<ul><li>主机在中心服务器上注册其资源</li><li>主机向中心服务器查询资源位置</li></ul></li><li>文件传输：P2P</li></ul></li><li>即时通信<ul><li>在线检测：集中<ul><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户与中心服务器联系，以找到其在线好友的位置</li><li>两个用户的聊天：P2P</li></ul></li></ul></li></ul></li></ul></li><li><p>进程通信</p><ul><li>客户端进程：发起通信的进程</li><li>服务器进程：等待连接的进程<ul><li>在同一个主机中，使用<strong>进程通信机制</strong>通信</li><li>不同主机通过<strong>交换报文</strong>进行通信<ul><li>使用OS（操作系统）提供的通信服务</li><li>按照应用协议交换报文<ul><li>借助传输层提供的服务</li></ul></li></ul></li></ul></li><li>注意：P2P架构的应用也有客户端和服务器进程之分</li></ul></li><li><p>分布式进程通信需要解决的问题</p><ul><li>进程标识和寻址问题（<strong>服务用户</strong>）<ul><li>进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）<ul><li>主机：唯一的32位IP地址<ul><li>仅仅用IP地址不能够唯一的标识一个进程，在一台端系统上有很多应用进程在运行</li></ul></li><li>采用的传输层协议：TCP or UDP</li><li>端口号（Port Numbers）<ul><li>下面是一些知名端口号例子<ul><li>HTTP：TCP 80</li><li>Mail:TCP 25</li><li>ftp:TCP 2</li></ul></li></ul></li><li>一个进程用IP+Port标识端节点</li><li>本质上，一对主机进程之间的通信由2个端节点构成</li></ul></li></ul></li></ul></li><li><p>传输层提供的服务-需要穿过层间的信息</p><ul><li>层间接口必须要携带的信息<ul><li>要传输的报文（对于本层来说：SDU）</li><li>谁传的：己方的应用进程的标示：IP+TCP(UDP)端口</li><li>传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口</li></ul></li><li>传输层实体（TCP或UDP实体）根据这些信息进行TCP报文段（UDP数据报）的封装<ul><li>源端口号，目标端口号，数据等</li><li>将IP地址往下交IP实体，用于封装IP和数据报：源IP和目标IP</li></ul></li></ul></li><li><p>传输层提供的服务-层间信息的代表</p><ul><li>如果Socket API每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理-&gt;使用套接字</li><li>用个代号标示通信的双方或者单方：socket</li><li>TCP socket这里先不说，后面会有详细的说明</li><li>UDP socket这里先不说，后面会有详细的说明</li></ul></li><li><p>应用层协议：定义了：运行在不同端系统上的应用进程如何相互交换报文</p><ul><li>交换的报文类型：请求和应答报文</li><li>各种报文类型的语法：报文中各个字段及其描述</li><li>字段的语义：字段取值的含义</li><li>进程何时、如何发送报文以及对报文进行响应的规则<ul><li>应用协议仅仅是应用的一个组成部分<ul><li>Web应用：HTTP协议、web客户端、web服务器、HTML</li></ul></li></ul></li></ul></li><li><p>应用层需要传输层提供什么样的服务？如何描述传输层的服务？</p><ul><li><p>数据丢失率</p><ul><li>有些应用要求100%的可靠数据传输，例如文件</li><li>有些应用，例如音频，能荣仍一定比例数据的丢失</li></ul></li><li><p>延迟</p><ul><li>延迟、延迟差，比如电话，打游戏的延迟</li></ul></li><li><p>吞吐</p><ul><li>一些应用，例如多媒体，必须需要最小限度的吞吐，从而使得应用能够有效的运转</li><li>一些应用能够充分利用可供使用的吞吐（弹性应用）</li></ul></li><li><p>安全性</p><ul><li><p>机密性</p></li><li><p>完整性</p></li><li><p>可鉴别性</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929151608.png"></p></li></ul></li></ul></li><li><p>TCP服务</p><ul><li>可靠的数据传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐保证和安全</li><li>面向连接：要求客户端进程和服务器进程之间建立连接</li></ul></li><li><p>UDP服务</p><ul><li>不可靠的数据传输服务</li><li>不提供的服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接</li></ul></li><li><p>UDP<strong>存在的必要性</strong></p><ul><li>能够区分不同进程，而IP服务不能<ul><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li>无需建立连接</li><li>不做可靠的工作，例如检错重发</li><li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据<ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul></li><li><p>安全TCP</p><ul><li>TCP&amp;UDP<ul><li>都没有加密</li></ul></li><li>SSL<ul><li>在TCP上面实现，提供加密的TCP连接，具有私密性，数据完整性，端到端的鉴别</li><li>SSL在应用层，使用SSL库，而SSL库使用TCP通信</li><li>SSL socket API 应用将明文交给socket，SSL将其加密并在互联网上传输</li></ul></li></ul></li></ul><h1 id="三、Web-and-HTTP"><a href="#三、Web-and-HTTP" class="headerlink" title="三、Web and HTTP"></a>三、Web and HTTP</h1><ul><li><p>HTTP是<strong>无状态</strong>的</p><ul><li>服务器并不会维护关于客户的任何信息</li></ul></li><li><p>维护状态的协议很复杂</p><ul><li>必须维护历史信息（状态）</li><li>如果服务器/客户端死机，它们的状态信息可能不一致，二者的信息必须是一致</li><li>无状态的服务器能够支持更多的客户端</li></ul></li><li><p>HTTP连接</p><ul><li>非持久的HTTP<ul><li>最多只有一个对象在TCP连接上发送</li><li>下载多个对象需要多个TCP连接</li><li>HTTP/1.0 使用非持久性连接</li></ul></li><li>非持久的HTTP特点<ul><li>每个对象要2个RTT</li><li>操作系统必须为每个TCP连接分配资源</li><li>但浏览器通常打开并行TCP连接，以获取引用对象</li></ul></li><li>持久HTTP<ul><li>多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</li><li>HTTP/1.1 默认使用持久连接</li></ul></li><li>持久HTTP特点<ul><li>服务器在发送响应后，仍保持TCP连接</li><li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</li></ul></li><li>非流水式的持久HTTP<ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个RTT</li></ul></li><li>流水式的持久HTTP<ul><li>HTTP/1.1的默认模式</li><li>客户端遇到一个引用对象就立即产生一个请求</li><li>所有引用（小）对象只花费一个RTT是可能的</li></ul></li></ul></li><li><p>HTTP请求报文</p><ul><li>两种类型的HTTP报文：请求、响应</li><li>相关方法类型：GET、POST、HEAD、PUT、DELETE</li></ul></li><li><p>HTTP响应状态码</p><p>他们位于服务器-&gt;客户端的响应报文的首行</p><ul><li><p>200 OK 请求成功，请求对象包含在响应报文的后续部分</p></li><li><p>301 Moved Permanently  </p><p>请求的对象已经被永久转移了，新的URL在响应报文的Location,首部行中指定</p><p>客户端软件自动用新的URL去获取对象</p></li><li><p>400 Bad Request 一个通用的差错代码，表示该请求不能被服务器解读</p></li><li><p>404 Not Found 请求的文档在该服务上没有找到</p></li><li><p>505 HTTP Version Not Supported</p></li></ul></li><li><p>用户-服务器状态：cookies 大多数主要的门户网站使用cookies</p><ul><li>四个组成部分<ul><li>在HTTP响应报文中有一个cookies的首部行</li><li>在HTTP请求报文含有一个cookies的首部行</li><li>在用户端系统中保留有一个cookies文件，由用户的浏览器管理</li><li>在Web站点有一个后端数据库</li></ul></li><li>Cookies能带来什么<ul><li>用户验证</li><li>购物车</li><li>推荐</li><li>用户状态</li></ul></li><li>如何维护<ul><li>协议端节点：在多个事务上，发送端和接收端维持状态</li><li>cookies:http报文携带状态信息</li></ul></li><li>Cookies与隐私<ul><li>Cookies允许站点知道许多关于用户的信息、</li><li>可能将它知道的东西卖给第三方</li><li>使用重定向和cookies的搜索引擎还能知道用户更多的信息<ul><li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li></ul></li><li>广告公司从站点获得信息</li></ul></li></ul></li><li><p>Web缓存</p><p>目标：避免每次都访问服务器，减少服务器的工作需求</p><ul><li>在缓存中的对象：缓存直接返回对象</li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li><li>缓存既是客户端又是服务器</li><li>通常缓存是由ISP安装（大学、公司、居民区ISP）</li><li><strong>为什么要使用Web缓存？</strong><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li><li>互联网大量采用了缓存；可以使较弱的ICP也能够有效提供内容</li></ul></li><li>条件GET方法<ul><li>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</li><li>缓存器：在HTTP请求中指定缓存拷贝的日期</li><li>服务器：如果缓存拷贝陈旧，则响应报文没包含对象</li></ul></li></ul></li></ul><h1 id="四、FTP"><a href="#四、FTP" class="headerlink" title="四、FTP*"></a>四、FTP*</h1><h1 id="五、Email"><a href="#五、Email" class="headerlink" title="五、Email"></a>五、Email</h1><h1 id="六、DNS"><a href="#六、DNS" class="headerlink" title="六、DNS"></a>六、DNS</h1><h1 id="七、P2P应用"><a href="#七、P2P应用" class="headerlink" title="七、P2P应用"></a>七、P2P应用</h1><h1 id="八、CDN"><a href="#八、CDN" class="headerlink" title="八、CDN"></a>八、CDN</h1><h1 id="九、TCP套接字（Socket）编程"><a href="#九、TCP套接字（Socket）编程" class="headerlink" title="九、TCP套接字（Socket）编程"></a>九、TCP套接字（Socket）编程</h1><h1 id="十、UDP套接字编程"><a href="#十、UDP套接字编程" class="headerlink" title="十、UDP套接字编程"></a>十、UDP套接字编程</h1><h1 id="十一、碎碎念"><a href="#十一、碎碎念" class="headerlink" title="十一、碎碎念"></a>十一、碎碎念</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记-第一章</title>
    <link href="/2022/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2022/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929154156.png"></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>🍓前言内容对应的课程是p1和p2，很多同学看这一章的时候觉得很难，因为涉及了好多好多专有名词，可能会听着迷迷糊糊，我的建议是可以暂时听一遍，有一个大致的脉络就行。这两节课可以等你学完这门课程之后再回来温习一下，我相信你会醍醐灌顶的。好啦下面让我带你进入计算机网络的第一章吧！！！</p><h1 id="二、什么是Internet"><a href="#二、什么是Internet" class="headerlink" title="二、什么是Internet"></a>二、什么是Internet</h1><p>这个问题我们可以从两个方向来回答</p><p>🍉<strong>从具体构成角度</strong></p><ul><li><input disabled type="checkbox"> 节点<ul><li>主机及其上运行的应用程序（用方形表示）</li><li>路由器、交换机等网络交换设备（用圆形表示）</li><li>边：通信链路</li><li>接入网链路（access)：主机连接到互联网的链路，连接方形设备和圆形设备</li><li>主干链路（backbone）：路由器间的链路，连接圆形设备</li></ul></li><li><input disabled type="checkbox"> 协议<ul><li>端系统、分组交换机和其他因特网部件都要遵守一系列协议，这些协议控制因特网中信息的发送和接收</li><li>按层级不同，可以分为物理层协议，链路层协议，网络层协议，传输层协议和应用层协议，每一层的协议又可以分为若干种，如传输层协议有TCP,UDP；网络层协议有IP，一些路由选择协议。</li><li>因特网最为主要的两个协议是TCP（Transmission Control Protoclo，传输控制协议）和IP（Internet Protoclo，网络协议）</li><li>因特网的主要协议统称为TCP/IP，而计算机网络的主要协议不一定是TCP/IP，所以计算机网络是一个更大范围的概念</li></ul></li><li><input disabled type="checkbox"> 数以亿计的、互联的计算设备：<ul><li>主机即端系统，包括传统的桌面电脑，Linux工作站以及所谓的服务器，也包括我们的手机，平板、电视、一些穿戴设备等</li><li>运行网络应用程序</li></ul></li><li><input disabled type="checkbox"> 通信链路<ul><li>光纤、同轴电缆、无线、卫星</li><li>传输速率 = 带宽（bps）是以比特/秒（bit/s，或bps）来度量的</li></ul></li><li><input disabled type="checkbox"> 分组交换设备：转发分组（packets）<ul><li>路由器和交换机 二者区别：前者通常用于网络核心中，后者通常用于接入网中</li></ul></li><li><input disabled type="checkbox"> 路径<ul><li>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径</li></ul></li></ul><p>🍉<strong>从服务角度</strong></p><ul><li><input disabled type="checkbox"> 使用通信设施进行通信的分布式应用：<ul><li>将发送和接受数据的apps与互联网连接起来</li><li>为app应用提供服务选择，类似与邮政服务：无连接不可靠服务，面向连接的可靠服务</li></ul></li></ul><h1 id="三、网络边缘"><a href="#三、网络边缘" class="headerlink" title="三、网络边缘"></a>三、网络边缘</h1><p>🍑我们知道，网络结构分为网络边缘（edge），网络核心（core）和接入网(access）</p><p>网络边缘</p><ul><li>主机、端系统：与因特网相连的计算机和其他设备，它们都位于因特网的边缘，所以被称为端系统。端系统也称为主机（host），因为它们容纳（即运行）应用程序。主机可以进一步划分为两类：客户端（client）和服务器（server）。客户端是发起请求的一方，服务器是接收请求的一方。大部分提供搜索结果、电子邮件、Web 页面和视频的服务器都属于大型数据中心（data center）</li><li>应用进程通信的模式：客户/服务器模式（主从模式）和对等（peer-peer）模式<ul><li>客户端/服务器模式的缺点：可扩展性差</li><li>对等模式：很少（甚至没有）专门的服务器，可扩展性好，如分布式文件分发应用程序迅雷。每一个应用程序既可以作为客户端，也可以作为服务端</li></ul></li></ul><p>网络边缘：采用网络设施的面向连接服务</p><ul><li>在数据传输之前两个主机先要握手，建立连接（准备好相应的资源（缓存区，重置控制变量，设置超时定时器），做好标记）。TCP 在 Internet 上提供面向连接的服务，特点是可靠（不出错，不丢失，不重复，不冗余，也叫 RDT Reliable Data Transfer）、有序、有流量控制和拥塞控制。使用 TCP 的应用：Http应用、FTP（文件传输）</li></ul><p>网络边缘：采用基础设施的无连接服务</p><ul><li><p>UDP 在 Internet 上提供无连接的服务，特点是不可靠，没有流量控制和拥塞控制。使用 UDP 的应用：流媒体应用、远程会议</p><p>注意：面向连接和有连接是不同的：面向连接，通信的状态只是在端系统中维护，而不在数据交换节点中维护；有连接，通信的状态不仅要在端系统中维护，也要在数据交换节点中维护</p></li></ul><h1 id="四、网络核心"><a href="#四、网络核心" class="headerlink" title="四、网络核心"></a>四、网络核心</h1><p>🍍网络核心是由分组交换机和链路构成的网状网络，主要作用是数据交换</p><p>通过网络链路和交换机移动数据的有两种基本方法：电路交换(circuit switching)和分组交换(packet switching)</p><ul><li><p>电路交换</p><ul><li>在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存、链路传输速率）</li><li>在发送方发送信息之前，电路交换方式必须在发送方和接收方之间建立一条连接，被称为电路；同时，建立这条电路，需要消耗一定的时间</li><li>沿着发送方和接收方之间路径上的交换机都将为建立的连接维护连接状态，这导致了电路交换方式可靠性不高的问题（因为只要有一个交换机出问题了，连接就被打破了）</li><li>在连接期间，电路在该网络链路上预留了恒定的传输速率，这保证了通信的性能</li><li>给这条电路分配的资源是这条电路独享的资源，这样如果这条电路上没有数据发送，这些资源就会被浪费</li><li>电路一般不会占用全部的链路，如果把一条链路（1Mbps）分配给一条电路（100Kbps），这是一种浪费。所以，要将链路分成片，分片方式有：频分复用（Frequency-Division Mutliplexing，FDM），时分复用（Time-Division Mutliplexing，TDM），波分复用（Wave-Division Mutliplexing，WDM）</li></ul></li><li><p>分组交换</p><p>在端系统间通信会话期间，不会预留端系统间沿路径通信所需要的资源（缓存、链路传输速率）</p><p>链路带宽资源不再分片，而是把全部带宽都用于通信</p><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>（store-and-forward transmission）机制。存储转发传输机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p><p>存储转发传输机制会带来存储转发时延</p><p>分组交换机具有一个输出缓存（output buffer，也称为输出队列（output queue）），用于存储转发到某条链路的分组。如果到达的分组需要到某条链路，但是该链路正在传输其他分组，那么这个到达的分组就必须在输出缓存中等待，这就带来了排队时延</p><p>当一个分组已到达需要排队，但是输出缓存已满，这时就会出现分组丢失（丢包）（packet loss）</p><p>路由器决定分组转发到哪条链路的原理：分组的首部包含了目的地的IP地址。每台路由器都有一个转发表（forwarding table），用于将目的地址（或目的地址的一部分）映射成输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索它的转发表，找到对应的输出链路。路由器将分组导向查到的那条输出链路</p><p>分组交换是时分复用使用链路资源，但是没有固定的划分模式，所以称为统计多路复用</p><p>分组交换网络按照有无网络层的连接，分成：数据报（datagram）网络和虚电路（virtual circuit）网络</p><p>下面是分组交换和电路交换的对比图以及内容</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923125612.png"></p></li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130110.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130218.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130323.png"></p><h1 id="五、接入网和物理媒介"><a href="#五、接入网和物理媒介" class="headerlink" title="五、接入网和物理媒介"></a>五、接入网和物理媒介</h1><p>🍐</p><ul><li><p>接入网</p><ul><li>接入网是指将端系统物理连接到其边缘路由器（edge router）的网络</li><li>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</li></ul></li><li><p>接入环境</p><ul><li><p>住宅接入</p><p><strong>数字用户线（digital subscriber line，DSL）</strong></p><p>采用现有的住宅到电话公司的电话线（即双绞铜线）来传输数据；实际上是住宅的DSL调制解调器（俗称为“猫”）使用现有的电话线与位于电话公司的本地中心局（center office，CO）中的数字用户线接入复用器（DSLAM）交换数据；电话线同时承载了数据和传统的电话信号。DSLAM 把数据和电话信号分隔开，将数据送往因特网。“猫”将数据调制为高频模拟信号在电话线上传输，将来自电话线的高频模拟信号解调为数据供用户主机使用。</p><p>调频方式用不同的频率进行编码： •高速下行信道，位于50kHz到1 MHz频段； •中速上行信道，位于4kHz到50kHz频段； •普通的双向电话信道，位于0到4kHz频段</p><p><strong>线缆网络</strong></p><p>采用现有的住宅到有线电视信号线缆（即同轴电缆）来传输数据；需要把有线电视信号线缆双向改造（原有的是只能下行的）；在这个系统中应用了光纤和同轴电缆，所以它经常被称为混合光纤同轴（Hybrid Fiber Coax, HFC）系统；电缆因特网需要电缆调制解调器（cable modem）；在电缆头端，电缆调制解调器端接系统（Cable Modem Termination System, CMTS）将模拟信号转换回数字形式，发往互联网。</p><p>电缆因特网接入的一个重要特征是共享广播媒体。</p><p>家里的无线路由器其实是包含路由器，交换机（实现局部交换），调制解调器，防火墙，无限接入点的集合</p><p><strong>光纤到户</strong></p><p>Fiber To The Home, FTTH，有潜力提供每秒千兆比特范围的因特网接入速率</p><p>企业、单位接入：使用局域网（LAN）将端系统连接到边缘路由器。以太网用户使用双绞铜线与一台以太网交换机相连。以太网交换机或者这样相连的交换机再与更大的互联网相连；使用以太网接入，用户通常以100Mbps或 lGbps速率接入以太网交换机，而服务器可能具有lGbps甚至10Gbps的接入速率</p><p>无线接入：无线LAN：Wifi，距离短；广域无线接入：基站，距离长</p></li></ul></li><li><p>物理媒介</p><ul><li>导引型媒体：同轴电缆，光纤，双绞线</li><li>非导引型媒体：地面微波，LAN，wide-area，卫星</li></ul></li></ul><h1 id="六、Internet结构和ISP"><a href="#六、Internet结构和ISP" class="headerlink" title="六、Internet结构和ISP"></a>六、Internet结构和ISP</h1><p>🍇</p><p>ISP 有很多：住宅的 ISP，学校的 ISP，机构的 ISP</p><p>ISP 之间必须是互联的，这样才能保证不同的端系统可以互相访问    </p><p>多个全局 ISP 把接入 ISP 连接在一起，全局 ISP 之间通过 IXP（Internet exchange point） 连接在一起</p><p>区域 ISP 接入一定区域的端系统通过 POP（Point of presence）接入，全局 ISP 通过 IXP 连接区域 ISP</p><p>ICP（Internet Content Provider），互联网内容提供商，如百度，微信，会构建专用的网络，为用户提供更好的服务。ICP 也会和 ISP 互联</p><p>POP：高层 ISP 面向客户网络的接入点，涉及费用结算</p><p>IXP：多个对等 ISP 互联互通之处，通常不涉及费用结算</p><h1 id="七、分组延时、丢失和吞吐量"><a href="#七、分组延时、丢失和吞吐量" class="headerlink" title="七、分组延时、丢失和吞吐量"></a>七、分组延时、丢失和吞吐量</h1><ul><li><p>分组丢失的原因</p><ul><li>链路的队列缓冲区容量有限</li><li>当分组到达一个满的队列时，该分组会丢失</li><li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li></ul></li><li><p>分组延时</p><ul><li>节点处理延时<ul><li>检查bit级差错</li><li>检查分组首部和决定将分组导向何处</li></ul></li><li>排队延时<ul><li>在输出链路上等待传输的时间</li><li>依赖于路由器的拥塞程度</li></ul></li><li>传输延时<ul><li>R = 链路带宽（bps)</li><li>L= 分组长度(bits)</li><li>将分组发送到链路上的时间 = L/R</li><li>存储转发延时</li></ul></li><li>传播延时<ul><li>d = 物理链路的长度</li><li>s = 在媒体上的传播速度（2e8 m/sec)</li><li>传播延时 = d/s</li></ul></li></ul></li><li><p>节点延时</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923133412.png"></p></li><li><p>吞吐量</p><ul><li><p>吞吐量的含义：在源端和目标端之间传输的效率（数据量/单位时间）</p><ul><li><p>瞬时吞吐量：在一个时间点的速率</p></li><li><p>平均吞吐量：在一个长时间内平均值</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923133901.png"></p></li></ul></li></ul></li><li><p>流量强度用于估计排队延时</p><ul><li>a 表示分组到达队列的平均速率（a 的单位是分组/秒，即pkt/s）</li><li>R 表示链路传输速率，即主机或路由器向链路发送数据的速率，从队列中推出比特的速率，单位：bps，即 b/s</li><li>L 表示分组长度（假定所有分组都是 L 比特组成的），单位是比特</li><li>假定该队列无限大，比率 La / R 被称为流量强度。L/R 表示从队列中推出一个分组的速率，单位是s/pkt，而 a 表示分组到达队列的速率，La/R &gt; 1，则表示分组到达队列的平均速率超过从该队列传输岀去的速率，这样会导致队列无限增加，排队延时也将无限增加。因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1</li></ul></li></ul><h1 id="八、协议层次和服务模型"><a href="#八、协议层次和服务模型" class="headerlink" title="八、协议层次和服务模型"></a>八、协议层次和服务模型</h1><ul><li><p>因特网的复杂性</p><ul><li>因特网有大量的应用程序和协议、各种类型的端系统、分组交换机以及各种类型的链路级媒体。因此，必须组织网络体系结构</li></ul></li><li><p>分层的网络体系结构</p><ul><li>模块化：把复杂的功能分成子功能，每个模块完成一个特定的子功能，各模块组合起来成为整体，完成整个系统所要求的功能，而分层是特殊的模块化，只有上下层模块之间才可以相互沟通，不允许跨层调用</li><li>将网络复杂的功能分成功能明确的层次，每一层实现其中一个或一组功能，提供给上层使用的那些功能被称为服务</li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务；在实现本层协议的时候，直接利用了下层提供的所有服务：本层要和对等层通信，需要使用下层提供的服务来实现</li><li>本层的服务：借助于下层提供的服务实现新的功能，也包括下层提供的服务</li><li>改变服务的实现不会影响该系统其他组件，这是因为该层对上面提供相同的服务（相同的层间接口），并且使用来自下面层次的相同服务，当这一层的实现变化时，该系统的其他部分保持不变</li><li>分层的缺点：效率低一些</li></ul></li><li><p>服务和服务访问点</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134801.png"></li></ul></li><li><p>服务的类型</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134845.png"></li><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimage-20220923134918106.png"></li></ul></li><li><p>数据单元（DU）</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134950.png"><ul><li>SDU：service data unit 服务数据单元，上层交给下层传输的数据</li><li>ICI：interface control information 接口控制信息</li><li>IDU （interface data unit）= ICI + SDU</li><li>PDU：protocol data unit 协议数据单元，包括上层叫下来的数据和本层的头部信息</li></ul></li></ul></li><li><p>Internet协议栈</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135105.png"></li></ul></li><li><p>ISO/OSI参考模型</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135138.png"></li></ul></li><li><p>各层次的协议数据单元</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135214.png"></li></ul></li><li><p>封装与解封装</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135256.png"></li></ul></li></ul><h1 id="九、计算机网络和因特网的历史"><a href="#九、计算机网络和因特网的历史" class="headerlink" title="九、计算机网络和因特网的历史"></a>九、计算机网络和因特网的历史</h1><ul><li><p>1960以前，线路交换网络的时代</p></li><li><p>1961~1964，分组交换理论建立</p></li><li><p>1961~1972，分组交换实验网络 ARPAnet（是互联网的前身）</p></li><li><p>1972~1980，专用网络和网络互联</p></li><li><p>1974: 网际互联的Cerf and Kahn 体系结构</p></li><li><p>1980~1990，体系结构变化, 网络数量激增，应用丰富</p></li><li><p>1983 TCP/IP 部署，标记日</p></li><li><p>1990, 2000’s，商业化, Web, 新的应用</p></li><li><p>1990年初 Web 出现</p></li><li><p>2005~现在</p></li><li><p>移动互联网的时代</p></li><li><p>物联网的时代</p></li></ul><p><strong>最后</strong></p><p>终于总结完了，开心开心，忘记说了文章内容是学习中科大的计算机网络然后这里看一下那里看一下总结的笔记！</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SunnyWeather</title>
    <link href="/2022/09/13/SunnyWeather/"/>
    <url>/2022/09/13/SunnyWeather/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>前言</strong>：好久没有管理自己的博客了，最近心血来潮回来捯饬了一下自己的博客感觉还是很不错的，一开始嫌麻烦觉得在这里写文章很麻烦，但是自己真正用心来弄的时候会发现这个东西并不难。确实，很多时候我们在做什么之前都会去考虑所做之事自己是否能够完成或轻松的完成，而我在很多时候遇到一些比较复杂的事情或者难题的时候，都会有一种畏难心理，导致自己心理上去抵制它哈哈哈，属实是不够成熟。好伐啦，我们准备进入正题之前，我想大致分享一下本篇博客的创作源泉以及创作目的。最近在学习Kotlin的天气，发现自己暑假看书得来的知识没有掌握好，并且对很多Kotlin的知识都不够熟悉不够了解，甚至一些基本用法自己都还不会，然后不得不花费很多时间去改bug（抄书都抄错┭┮﹏┭┮），害，不过还是成功的解决了问题，也在bug中加深了自己对一些知识的理解，就还挺不错的哈哈哈。昨天已经写（写（×）抄（√））完天气了，虽然完成的比较草率(?)哈哈哈，不过也是在低下的效率中逐渐掌握了一些新的知识，故写这篇博客来记录一下自己的学习记录！好啦让我们一起开启SunnyWeather的知识之旅☞！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimgwallhaven-z8l37o.jpg"></p><h1 id="一、功能需求及技术可行性分析"><a href="#一、功能需求及技术可行性分析" class="headerlink" title="一、功能需求及技术可行性分析"></a>一、功能需求及技术可行性分析</h1><p>⭐我们在做一个项目之前，首先应该对程序进行需求分析，想一想我们的项目里面需要有什么，需要实现什么功能…我们才动手去实现这些功能。目前SunnyWeather中需要具备一下功能：</p><p>🌼可以搜索全球大多数国家的各个城市数据</p><p>🌼可以查看全球绝大多数城市的天气信息（准确程度取决于你所使用的天气API）</p><p>🌼可以自由切换城市，查看其他城市的数据</p><p>🌼可以手动刷新天气</p><p>以上是该项目主要的功能点，如果需要全部实现这些功能需要用到网络、数据存储、协程、线程等等技术，还是有一定的难度的，但是既然你发现这这篇宝藏博客，那么我将手把手教会你👊！</p><p>⭐上面只说了项目的主要功能以及需要实现的相关技术，却没有涉及一个关键的点，那就是天气的信息该怎么获取，这个不用担心，已经有大佬为你做好了，你只需要会调用就行了。</p><p>本篇博客以彩云天气为例，简单介绍如何获得彩云天气的API。</p><p>🍃首先登录<a href="https://dashboard.caiyunapp.com/">彩云天气</a>官网注册：<a href="https://dashboard.caiyunapp.com/">https://dashboard.caiyunapp.com/</a></p><p>🍃注册完了以后，申请令牌（<strong>重要</strong>），这里还需要让你填写应用链接，由于还没有创建，可以先不填。</p><p>🍃拿到令牌以后就可以使用彩云天气提供的各种API接口了。</p><h1 id="二、Git代码托管"><a href="#二、Git代码托管" class="headerlink" title="二、Git代码托管"></a>二、Git代码托管</h1><p>⭐这里就对Git就不介绍了，毕竟你都能看见我的博客，那你肯定也略知一二，我自己其实也不够了解没什么发言权。好了进入正题，首先你需要有一个Git账号，然后新建一个仓库（Repository），不需要勾选其他的东西，默认就行了，然后点击Create repository按钮就创建成功了。</p><p>🍌接下来就需要创建项目了，在Android studio中新建一个Kotlin项目，创建完需要去将仓库的远程版本库克隆到本地，将仓库的版本库中的Https复制一份，然后打卡cmd，进入你这个项目的目录下，输入git clone （这里是你项目仓库的Https），克隆成功需要做一件事情，那就是将SunnyWeather项目中的文件都复制到上一层目录，这样做的目的：可以将整个项目工程目录添加到版本控制中去，这里有个坑，在这些文件里面有一个隐藏文件（.git），需要你文件夹设置一下才能看见这些隐藏的文件，把所有的文件复制到上一层的时候会有一个文件.gitignote文件，直接覆盖就好，复制完将SunnyWeather文件夹删除。哈哈可能你会觉得有点麻烦，没办法，我一开始接触的时候也觉得麻烦，因为对计算机这些指令不熟悉很陌生，不过没关系，以后就会习惯了。最后，将SunnyWeather项目中的文件提交到Github上面。</p><p>具体指令如下(接着上面的操作继续)：</p><p>🍍git add .         添加操作</p><p>🍍git commit -m “（这里可以描述你这次提交代码的简单说明，比如：First commit）”</p><p>🍍git push origin main</p><p>👁到这一步完成就成功的实现了Git代码托管。</p><h1 id="三、搭建MVVM项目框架"><a href="#三、搭建MVVM项目框架" class="headerlink" title="三、搭建MVVM项目框架"></a>三、搭建MVVM项目框架</h1><p>⭐由于这是我第一次搭建MVVM项目框架加上自己本身对MVVM也不够了解，我就不展开介绍了，详细可以看这个<a href="https://blog.csdn.net/lmq121210/article/details/80872652?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166306818616782391895448%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166306818616782391895448&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-7-80872652-null-null.142%5Ev47%5Epc_rank_34_1,201%5Ev3%5Econtrol&utm_term=%E5%AE%89%E5%8D%93mvvm%E6%A1%86%E6%9E%B6&spm=1018.2226.3001.4187">大佬的文章</a>，我们的项目需要严格按照MVVM项目框架进行搭建。在你的项目的包下新建几个包，项目结构如下图所示。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913192832.png"></p><p>图中的logic包用于存放业务逻辑相关的代码，ui包用于存放页面展示相关的代码，而logic包下的dao、mode、network分别用于存放数据访问对象、对象模型以及网络相关的代码，ui包下的place和weather则是SunnyWeather中的两个主要界面。由于这些操作会涉及网络和对象存储等操作，需要导包，编辑app/build.gradle文件，如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913193511.png"></p><h1 id="四、搜索全球城市数据"><a href="#四、搜索全球城市数据" class="headerlink" title="四、搜索全球城市数据"></a>四、搜索全球城市数据</h1><p>⭐在开始写代码之前，我们可以先准备一些方便后期编程的一些工具类，这里需要写一样获得全局Context的工具类，并且将令牌配置在这里面。在你的项目的包下，新建一个SunnyWeatherApplycation类，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194107.png"></p><p>红色箭头所指填你申请到的令牌~</p><p>然后我们还需要在AndroidManifest.xml文件中更改android：name指定的内容，改为.SunnyWeatherApplication。</p><p>根据彩云天气的API文档，接下来我们开始定义相关的数据模型。</p><p>⭐在logic/model包下新建PlaceResponse.kt文件,并在这个文件中编写如下代码：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194417.png"></p><p>⭐接着定义彩云天气测试搜索API的Retrofit接口，在logic/network包下新建PlaceService接口，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194620.png"></p><p>⭐定义好了PlaceSertvice接口，我们需要使用它的前提得需要有一个Retrofir构建器，在logic/network包下新建一个ServiceCreator单例类，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194907.png"></p><p>⭐然后我们需要再定义一个统一的网络数据源访问入口，对所有散落请求的API进行封装。同样在logic/network包下新建一个SunnyWeatherNetwork单例类，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195230.png"></p><p>⭐另外我们需要在logic包下新建一个Repository单例类，这是仓库层的统一封装入口，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195543.png"></p><p>⭐到这里，逻辑层的实现就只剩最后一步了，定义ViewModel层，这里对ViewModel层解释一下，它相当于逻辑层和UI层的一个桥梁，虽然它更偏向于逻辑层。在ui/place包下新建一个PlaceViewModel，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195904.png"></p><p>🍉由于作者很懒，就不进行详细讲解了，天气的UI层代码以及RecyclerView的适配器和展示天气的PlaceFragment可以去我仓库clone查看，我就不在码字了，我的<a href="https://github.com/Crwei996/SunnyWeather">Github</a>，仓库名字即SunnyWeather。</p><p>注意：由于PlaceFragment中实现了一个搜索框布局，需要修改原生的ActionBar，修改res/values/theme.xml中的代码</p><p>改成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;style name=<span class="hljs-string">&quot;Theme.SunnyWeather&quot;</span> parent=<span class="hljs-string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>最后别忘记添加网络权限，AndroidManifest.xml文件中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;uses-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>完成这些就可以实现全球城市的搜索了，可以看我的Demo，这里不多放图了。</p><p>好了，关于城市搜索这块的代码就先写到这，现在提交代码到Github中去。</p><p>🍃git add .         添加操作</p><p>🍃git commit -m “（这里可以描述你这次提交代码的简单说明，比如：实现搜索全球城市数据功能）”</p><p>🍃git push origin main </p><h1 id="五、显示天气信息"><a href="#五、显示天气信息" class="headerlink" title="五、显示天气信息"></a>五、显示天气信息</h1><p>这一部分的逻辑和实现全球城市的搜索类似，根据API天气信息接口返回的JSON数据进行解析，具体操作如下：</p><p>⭐首先建立数据模型，在logic/model包下新建DailyResponse.kt文件，代码如下：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913202821.png"></p><p>🥥接着定义一个用于访问天气API的Retrofit接口，在logic/network包下新建WeatherService接口，代码如下：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203128.png"></p><p>⚡在SunnyWeatherNetwork这个网络数据源访问入口对新增的WeatherService接口进行封装，添加如下代码到SunnyWeatherNetwork：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203431.png"></p><p>💧完成了网络层的代码编写，和之前一样，创建仓库层，不过前面已经创建仓库层Repository了，在Repository中添加如下代码：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203625.png"></p><p>🍇到这逻辑层就只剩最后一步了，定义ViewModel层，在ui/weather包下新建一个WeatherViewModel，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203856.png"></p><p>⚽又到了我要偷懒的UI层了，和上面的ui层一样去我仓库clone项目自己去看把，我手敲的好累。</p><p>📕天气的页面布局完成以后，我们还需要一个转换函数，将获得到的天气代码转成一个Sky对象，为什么要这样，因为返回的数据是这样的…哈哈哈哈，在logic/model包下新建一个Sky.kt文件，代码如下所示：（这里太长了就不截图了，截图截不全）</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tp">class Sky(val info:String,val icon:Int,val bg:Int)<br>private val sky = mapOf(<br>    <span class="hljs-string">&quot;CLEAR_DAY&quot;</span> to Sky(<span class="hljs-string">&quot;晴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;CLEAR_NIGHT&quot;</span> to Sky(<span class="hljs-string">&quot;晴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;PARTLY_CLOUDY_DAY&quot;</span> to Sky(<span class="hljs-string">&quot;多云&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;PARTLY_CLOUDY_NIGHT&quot;</span> to Sky(<span class="hljs-string">&quot;多云&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;CLOUDY&quot;</span> to Sky(<span class="hljs-string">&quot;阴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;WINDY&quot;</span> to Sky(<span class="hljs-string">&quot;大风&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;LIGHT_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;小雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;MODERATE_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;中雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;HEAVY_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;大雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;STORM_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;暴雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;THUNDER_SHOWER&quot;</span> to Sky(<span class="hljs-string">&quot;雷阵雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;SLEET&quot;</span> to Sky(<span class="hljs-string">&quot;雨夹雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;LIGHT_SHOW&quot;</span> to Sky(<span class="hljs-string">&quot;小雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;MODERATE_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;中雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HEAVY_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;大雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;STORM_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;暴雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HAIL&quot;</span> to Sky(<span class="hljs-string">&quot;冰雹&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;LIGHT_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;轻度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;MODERATE_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;重度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HEAVY_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;重度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;FOG&quot;</span> to Sky(<span class="hljs-string">&quot;雾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;DUST&quot;</span> to Sky(<span class="hljs-string">&quot;浮尘&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img)<br><br>    )<br>fun getSky(skycon:String):Sky&#123;<br>    return sky[skycon] ?:sky[<span class="hljs-string">&quot;CLEAR_DAY&quot;</span>]<span class="hljs-comment">!!</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>由于省事，我就没有给相应的天气设置相应的背景图和图标了，你有兴趣的话可以自己去找图片和图标添加，关于天气自定义图标添加可以去看我在csdn写的一篇博客☞<a href="https://blog.csdn.net/qq_60387902/article/details/126664727?spm=1001.2014.3001.5501">Android studio使用阿里巴巴图标矢量图库</a>！</p><h1 id="六、手动刷新天气和切换城市"><a href="#六、手动刷新天气和切换城市" class="headerlink" title="六、手动刷新天气和切换城市"></a>六、手动刷新天气和切换城市</h1><p>☀手动刷新天气简单，这里就不详细说了，使用一个SwipeRefreshLayout布局就行，详细步骤看我的项目demo，里面很详细。</p><p>🌙切换城市也是一个DrawerLayout布局的事情，也不细说了，看demo。需要注意的是，在侧滑菜单消失以后记得隐藏输入法，你可以试试不隐藏输入法时的效果，在DrawerLayout的监听里实现相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">drawerLayout.addDrawerListener(object :DrawerLayout.DrawerListener&#123;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerSlide</span><span class="hljs-params">(drawerView: View, slideOffset: Float)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerOpened</span><span class="hljs-params">(drawerView: View)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;ServiceCast&quot;)</span><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerClosed</span><span class="hljs-params">(drawerView: View)</span> </span>&#123;<br>        <span class="hljs-comment">//因为弹出这个滑动菜单以后，如果想输入新的地址会弹出一个输入法，如果在你输完以后直接就关闭滑动菜单的话需要把输入法也关闭</span><br>        <span class="hljs-comment">//关闭弹出的输入法</span><br>        val manager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager<br>        manager.hideSoftInputFromWindow(drawerView.windowToken,InputMethodManager.HIDE_NOT_ALWAYS)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerStateChanged</span><span class="hljs-params">(newState: Int)</span> </span>&#123;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最后一个阶段的开发任务也完成了，记得提交代码</p><p>🍓git add .         添加操作</p><p>🍓git commit -m “（这里可以描述你这次提交代码的简单说明，比如：新增切换城市和手动更新天气的功能）”</p><p>🍓git push origin main </p><h1 id="七、项目提升"><a href="#七、项目提升" class="headerlink" title="七、项目提升"></a>七、项目提升</h1><p>这个项目我是根据郭霖的《第一行代码》写的，我的demo过于简陋，很多能简单的就简单，以及一些ui可能你会觉得好丑或者什么，你可以自行修改；或者说你觉得天气显示的太少了或者不够精美不够详细，你也可以根据彩云天气的API自行修改……终于敲完了，好累好累好累！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913205647.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
