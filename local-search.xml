<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络笔记-第一章</title>
    <link href="/2022/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2022/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>🍓前言内容对应的课程是p1和p2，很多同学看这一章的时候觉得很难，因为涉及了好多好多专有名词，可能会听着迷迷糊糊，我的建议是可以暂时听一遍，有一个大致的脉络就行。这两节课可以等你学完这门课程之后再回来温习一下，我相信你会醍醐灌顶的。好啦下面让我带你进入计算机网络的第一章吧！！！</p><h1 id="二、什么是Internet"><a href="#二、什么是Internet" class="headerlink" title="二、什么是Internet"></a>二、什么是Internet</h1><p>这个问题我们可以从两个方向来回答</p><p>🍉<strong>从具体构成角度</strong></p><ul><li><input disabled type="checkbox"> 节点<ul><li>主机及其上运行的应用程序（用方形表示）</li><li>路由器、交换机等网络交换设备（用圆形表示）</li><li>边：通信链路</li><li>接入网链路（access)：主机连接到互联网的链路，连接方形设备和圆形设备</li><li>主干链路（backbone）：路由器间的链路，连接圆形设备</li></ul></li><li><input disabled type="checkbox"> 协议<ul><li>端系统、分组交换机和其他因特网部件都要遵守一系列协议，这些协议控制因特网中信息的发送和接收</li><li>按层级不同，可以分为物理层协议，链路层协议，网络层协议，传输层协议和应用层协议，每一层的协议又可以分为若干种，如传输层协议有TCP,UDP；网络层协议有IP，一些路由选择协议。</li><li>因特网最为主要的两个协议是TCP（Transmission Control Protoclo，传输控制协议）和IP（Internet Protoclo，网络协议）</li><li>因特网的主要协议统称为TCP/IP，而计算机网络的主要协议不一定是TCP/IP，所以计算机网络是一个更大范围的概念</li></ul></li><li><input disabled type="checkbox"> 数以亿计的、互联的计算设备：<ul><li>主机即端系统，包括传统的桌面电脑，Linux工作站以及所谓的服务器，也包括我们的手机，平板、电视、一些穿戴设备等</li><li>运行网络应用程序</li></ul></li><li><input disabled type="checkbox"> 通信链路<ul><li>光纤、同轴电缆、无线、卫星</li><li>传输速率 = 带宽（bps）是以比特/秒（bit/s，或bps）来度量的</li></ul></li><li><input disabled type="checkbox"> 分组交换设备：转发分组（packets）<ul><li>路由器和交换机 二者区别：前者通常用于网络核心中，后者通常用于接入网中</li></ul></li><li><input disabled type="checkbox"> 路径<ul><li>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径</li></ul></li></ul><p>🍉<strong>从服务角度</strong></p><ul><li><input disabled type="checkbox"> 使用通信设施进行通信的分布式应用：<ul><li>将发送和接受数据的apps与互联网连接起来</li><li>为app应用提供服务选择，类似与邮政服务：无连接不可靠服务，面向连接的可靠服务</li></ul></li></ul><h1 id="三、网络边缘"><a href="#三、网络边缘" class="headerlink" title="三、网络边缘"></a>三、网络边缘</h1><p>🍑我们知道，网络结构分为网络边缘（edge），网络核心（core）和接入网(access）</p><p>网络边缘</p><ul><li>主机、端系统：与因特网相连的计算机和其他设备，它们都位于因特网的边缘，所以被称为端系统。端系统也称为主机（host），因为它们容纳（即运行）应用程序。主机可以进一步划分为两类：客户端（client）和服务器（server）。客户端是发起请求的一方，服务器是接收请求的一方。大部分提供搜索结果、电子邮件、Web 页面和视频的服务器都属于大型数据中心（data center）</li><li>应用进程通信的模式：客户/服务器模式（主从模式）和对等（peer-peer）模式<ul><li>客户端/服务器模式的缺点：可扩展性差</li><li>对等模式：很少（甚至没有）专门的服务器，可扩展性好，如分布式文件分发应用程序迅雷。每一个应用程序既可以作为客户端，也可以作为服务端</li></ul></li></ul><p>网络边缘：采用网络设施的面向连接服务</p><ul><li>在数据传输之前两个主机先要握手，建立连接（准备好相应的资源（缓存区，重置控制变量，设置超时定时器），做好标记）。TCP 在 Internet 上提供面向连接的服务，特点是可靠（不出错，不丢失，不重复，不冗余，也叫 RDT Reliable Data Transfer）、有序、有流量控制和拥塞控制。使用 TCP 的应用：Http应用、FTP（文件传输）</li></ul><p>网络边缘：采用基础设施的无连接服务</p><ul><li><p>UDP 在 Internet 上提供无连接的服务，特点是不可靠，没有流量控制和拥塞控制。使用 UDP 的应用：流媒体应用、远程会议</p><p>注意：面向连接和有连接是不同的：面向连接，通信的状态只是在端系统中维护，而不在数据交换节点中维护；有连接，通信的状态不仅要在端系统中维护，也要在数据交换节点中维护</p></li></ul><h1 id="四、网络核心"><a href="#四、网络核心" class="headerlink" title="四、网络核心"></a>四、网络核心</h1><p>🍍网络核心是由分组交换机和链路构成的网状网络，主要作用是数据交换</p><p>通过网络链路和交换机移动数据的有两种基本方法：电路交换(circuit switching)和分组交换(packet switching)</p><ul><li><p>电路交换</p><ul><li>在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存、链路传输速率）</li><li>在发送方发送信息之前，电路交换方式必须在发送方和接收方之间建立一条连接，被称为电路；同时，建立这条电路，需要消耗一定的时间</li><li>沿着发送方和接收方之间路径上的交换机都将为建立的连接维护连接状态，这导致了电路交换方式可靠性不高的问题（因为只要有一个交换机出问题了，连接就被打破了）</li><li>在连接期间，电路在该网络链路上预留了恒定的传输速率，这保证了通信的性能</li><li>给这条电路分配的资源是这条电路独享的资源，这样如果这条电路上没有数据发送，这些资源就会被浪费</li><li>电路一般不会占用全部的链路，如果把一条链路（1Mbps）分配给一条电路（100Kbps），这是一种浪费。所以，要将链路分成片，分片方式有：频分复用（Frequency-Division Mutliplexing，FDM），时分复用（Time-Division Mutliplexing，TDM），波分复用（Wave-Division Mutliplexing，WDM）</li></ul></li><li><p>分组交换</p><p>在端系统间通信会话期间，不会预留端系统间沿路径通信所需要的资源（缓存、链路传输速率）</p><p>链路带宽资源不再分片，而是把全部带宽都用于通信</p><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>（store-and-forward transmission）机制。存储转发传输机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p><p>存储转发传输机制会带来存储转发时延</p><p>分组交换机具有一个输出缓存（output buffer，也称为输出队列（output queue）），用于存储转发到某条链路的分组。如果到达的分组需要到某条链路，但是该链路正在传输其他分组，那么这个到达的分组就必须在输出缓存中等待，这就带来了排队时延</p><p>当一个分组已到达需要排队，但是输出缓存已满，这时就会出现分组丢失（丢包）（packet loss）</p><p>路由器决定分组转发到哪条链路的原理：分组的首部包含了目的地的IP地址。每台路由器都有一个转发表（forwarding table），用于将目的地址（或目的地址的一部分）映射成输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索它的转发表，找到对应的输出链路。路由器将分组导向查到的那条输出链路</p><p>分组交换是时分复用使用链路资源，但是没有固定的划分模式，所以称为统计多路复用</p><p>分组交换网络按照有无网络层的连接，分成：数据报（datagram）网络和虚电路（virtual circuit）网络</p><p>下面是分组交换和电路交换的对比图以及内容</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923125612.png"></p></li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130110.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130218.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130323.png"></p><h1 id="五、接入网和物理媒介"><a href="#五、接入网和物理媒介" class="headerlink" title="五、接入网和物理媒介"></a>五、接入网和物理媒介</h1><p>🍐</p><ul><li><p>接入网</p><ul><li>接入网是指将端系统物理连接到其边缘路由器（edge router）的网络</li><li>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</li></ul></li><li><p>接入环境</p><ul><li><p>住宅接入</p><p><strong>数字用户线（digital subscriber line，DSL）</strong></p><p>采用现有的住宅到电话公司的电话线（即双绞铜线）来传输数据；实际上是住宅的DSL调制解调器（俗称为“猫”）使用现有的电话线与位于电话公司的本地中心局（center office，CO）中的数字用户线接入复用器（DSLAM）交换数据；电话线同时承载了数据和传统的电话信号。DSLAM 把数据和电话信号分隔开，将数据送往因特网。“猫”将数据调制为高频模拟信号在电话线上传输，将来自电话线的高频模拟信号解调为数据供用户主机使用。</p><p>调频方式用不同的频率进行编码： •高速下行信道，位于50kHz到1 MHz频段； •中速上行信道，位于4kHz到50kHz频段； •普通的双向电话信道，位于0到4kHz频段</p><p><strong>线缆网络</strong></p><p>采用现有的住宅到有线电视信号线缆（即同轴电缆）来传输数据；需要把有线电视信号线缆双向改造（原有的是只能下行的）；在这个系统中应用了光纤和同轴电缆，所以它经常被称为混合光纤同轴（Hybrid Fiber Coax, HFC）系统；电缆因特网需要电缆调制解调器（cable modem）；在电缆头端，电缆调制解调器端接系统（Cable Modem Termination System, CMTS）将模拟信号转换回数字形式，发往互联网。</p><p>电缆因特网接入的一个重要特征是共享广播媒体。</p><p>家里的无线路由器其实是包含路由器，交换机（实现局部交换），调制解调器，防火墙，无限接入点的集合</p><p><strong>光纤到户</strong></p><p>Fiber To The Home, FTTH，有潜力提供每秒千兆比特范围的因特网接入速率</p><p>企业、单位接入：使用局域网（LAN）将端系统连接到边缘路由器。以太网用户使用双绞铜线与一台以太网交换机相连。以太网交换机或者这样相连的交换机再与更大的互联网相连；使用以太网接入，用户通常以100Mbps或 lGbps速率接入以太网交换机，而服务器可能具有lGbps甚至10Gbps的接入速率</p><p>无线接入：无线LAN：Wifi，距离短；广域无线接入：基站，距离长</p></li></ul></li><li><p>物理媒介</p><ul><li>导引型媒体：同轴电缆，光纤，双绞线</li><li>非导引型媒体：地面微波，LAN，wide-area，卫星</li></ul></li></ul><h1 id="六、Internet结构和ISP"><a href="#六、Internet结构和ISP" class="headerlink" title="六、Internet结构和ISP"></a>六、Internet结构和ISP</h1><p>🍇</p><p>ISP 有很多：住宅的 ISP，学校的 ISP，机构的 ISP</p><p>ISP 之间必须是互联的，这样才能保证不同的端系统可以互相访问    </p><p>多个全局 ISP 把接入 ISP 连接在一起，全局 ISP 之间通过 IXP（Internet exchange point） 连接在一起</p><p>区域 ISP 接入一定区域的端系统通过 POP（Point of presence）接入，全局 ISP 通过 IXP 连接区域 ISP</p><p>ICP（Internet Content Provider），互联网内容提供商，如百度，微信，会构建专用的网络，为用户提供更好的服务。ICP 也会和 ISP 互联</p><p>POP：高层 ISP 面向客户网络的接入点，涉及费用结算</p><p>IXP：多个对等 ISP 互联互通之处，通常不涉及费用结算</p><h1 id="七、分组延时、丢失和吞吐量"><a href="#七、分组延时、丢失和吞吐量" class="headerlink" title="七、分组延时、丢失和吞吐量"></a>七、分组延时、丢失和吞吐量</h1><ul><li><p>分组丢失的原因</p><ul><li>链路的队列缓冲区容量有限</li><li>当分组到达一个满的队列时，该分组会丢失</li><li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li></ul></li><li><p>分组延时</p><ul><li>节点处理延时<ul><li>检查bit级差错</li><li>检查分组首部和决定将分组导向何处</li></ul></li><li>排队延时<ul><li>在输出链路上等待传输的时间</li><li>依赖于路由器的拥塞程度</li></ul></li><li>传输延时<ul><li>R = 链路带宽（bps)</li><li>L= 分组长度(bits)</li><li>将分组发送到链路上的时间 = L/R</li><li>存储转发延时</li></ul></li><li>传播延时<ul><li>d = 物理链路的长度</li><li>s = 在媒体上的传播速度（2e8 m/sec)</li><li>传播延时 = d/s</li></ul></li></ul></li><li><p>节点延时</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923133412.png"></p></li><li><p>吞吐量</p><ul><li><p>吞吐量的含义：在源端和目标端之间传输的效率（数据量/单位时间）</p><ul><li><p>顺势吞吐量：在一个时间点的速率</p></li><li><p>平均吞吐量：在一个长时间内平均值</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923133901.png"></p></li></ul></li></ul></li><li><p>流量强度用于估计排队延时</p><ul><li>a 表示分组到达队列的平均速率（a 的单位是分组/秒，即pkt/s）\</li><li>R 表示链路传输速率，即主机或路由器向链路发送数据的速率，从队列中推出比特的速率，单位：bps，即 b/s</li><li>L 表示分组长度（假定所有分组都是 L 比特组成的），单位是比特</li><li>假定该队列无限大，比率 La / R 被称为流量强度。L/R 表示从队列中推出一个分组的速率，单位是s/pkt，而 a 表示分组到达队列的速率，La/R &gt; 1，则表示分组到达队列的平均速率超过从该队列传输岀去的速率，这样会导致队列无限增加，排队延时也将无限增加。因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1</li></ul></li></ul><h1 id="八、协议层次和服务模型"><a href="#八、协议层次和服务模型" class="headerlink" title="八、协议层次和服务模型"></a>八、协议层次和服务模型</h1><ul><li><p>因特网的复杂性</p><ul><li>因特网有大量的应用程序和协议、各种类型的端系统、分组交换机以及各种类型的链路级媒体。因此，必须组织网络体系结构</li></ul></li><li><p>分层的网络体系结构</p><ul><li>模块化：把复杂的功能分成子功能，每个模块完成一个特定的子功能，各模块组合起来成为整体，完成整个系统所要求的功能，而分层是特殊的模块化，只有上下层模块之间才可以相互沟通，不允许跨层调用</li><li>将网络复杂的功能分成功能明确的层次，每一层实现其中一个或一组功能，提供给上层使用的那些功能被称为服务</li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务；在实现本层协议的时候，直接利用了下层提供的所有服务：本层要和对等层通信，需要使用下层提供的服务来实现</li><li>本层的服务：借助于下层提供的服务实现新的功能，也包括下层提供的服务</li><li>改变服务的实现不会影响该系统其他组件，这是因为该层对上面提供相同的服务（相同的层间接口），并且使用来自下面层次的相同服务，当这一层的实现变化时，该系统的其他部分保持不变</li><li>分层的缺点：效率低一些</li></ul></li><li><p>服务和服务访问点</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134801.png"></li></ul></li><li><p>服务的类型</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134845.png"></li><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimage-20220923134918106.png"></li></ul></li><li><p>数据单元（DU）</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134950.png"><ul><li>SDU：service data unit 服务数据单元，上层交给下层传输的数据</li><li>ICI：interface control information 接口控制信息</li><li>IDU （interface data unit）= ICI + SDU</li><li>PDU：protocol data unit 协议数据单元，包括上层叫下来的数据和本层的头部信息</li></ul></li></ul></li><li><p>Internet协议栈</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135105.png"></li></ul></li><li><p>ISO/OSI参考模型</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135138.png"></li></ul></li><li><p>各层次的协议数据单元</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135214.png"></li></ul></li><li><p>封装与解封装</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135256.png"></li></ul></li></ul><h1 id="九、计算机网络和因特网的历史"><a href="#九、计算机网络和因特网的历史" class="headerlink" title="九、计算机网络和因特网的历史"></a>九、计算机网络和因特网的历史</h1><ul><li><p>1960以前，线路交换网络的时代</p></li><li><p>1961~1964，分组交换理论建立</p></li><li><p>1961~1972，分组交换实验网络 ARPAnet（是互联网的前身）</p></li><li><p>1972~1980，专用网络和网络互联</p></li><li><p>1974: 网际互联的Cerf and Kahn 体系结构</p></li><li><p>1980~1990，体系结构变化, 网络数量激增，应用丰富</p></li><li><p>1983 TCP/IP 部署，标记日</p></li><li><p>1990, 2000’s，商业化, Web, 新的应用</p></li><li><p>1990年初 Web 出现</p></li><li><p>2005~现在</p></li><li><p>移动互联网的时代</p></li><li><p>物联网的时代</p></li></ul><p><strong>最后</strong></p><p>终于总结完了，开心开心，忘记说了文章内容是学习中科大的计算机网络然后这里看一下那里看一下总结的笔记！</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SunnyWeather</title>
    <link href="/2022/09/13/SunnyWeather/"/>
    <url>/2022/09/13/SunnyWeather/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>前言</strong>：好久没有管理自己的博客了，最近心血来潮回来捯饬了一下自己的博客感觉还是很不错的，一开始嫌麻烦觉得在这里写文章很麻烦，但是自己真正用心来弄的时候会发现这个东西并不难。确实，很多时候我们在做什么之前都会去考虑所做之事自己是否能够完成或轻松的完成，而我在很多时候遇到一些比较复杂的事情或者难题的时候，都会有一种畏难心理，导致自己心理上去抵制它哈哈哈，属实是不够成熟。好伐啦，我们准备进入正题之前，我想大致分享一下本篇博客的创作源泉以及创作目的。最近在学习Kotlin的天气，发现自己暑假看书得来的知识没有掌握好，并且对很多Kotlin的知识都不够熟悉不够了解，甚至一些基本用法自己都还不会，然后不得不花费很多时间去改bug（抄书都抄错┭┮﹏┭┮），害，不过还是成功的解决了问题，也在bug中加深了自己对一些知识的理解，就还挺不错的哈哈哈。昨天已经写（写（×）抄（√））完天气了，虽然完成的比较草率(?)哈哈哈，不过也是在低下的效率中逐渐掌握了一些新的知识，故写这篇博客来记录一下自己的学习记录！好啦让我们一起开启SunnyWeather的知识之旅☞！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimgwallhaven-z8l37o.jpg"></p><h1 id="一、功能需求及技术可行性分析"><a href="#一、功能需求及技术可行性分析" class="headerlink" title="一、功能需求及技术可行性分析"></a>一、功能需求及技术可行性分析</h1><p>⭐我们在做一个项目之前，首先应该对程序进行需求分析，想一想我们的项目里面需要有什么，需要实现什么功能…我们才动手去实现这些功能。目前SunnyWeather中需要具备一下功能：</p><p>🌼可以搜索全球大多数国家的各个城市数据</p><p>🌼可以查看全球绝大多数城市的天气信息（准确程度取决于你所使用的天气API）</p><p>🌼可以自由切换城市，查看其他城市的数据</p><p>🌼可以手动刷新天气</p><p>以上是该项目主要的功能点，如果需要全部实现这些功能需要用到网络、数据存储、协程、线程等等技术，还是有一定的难度的，但是既然你发现这这篇宝藏博客，那么我将手把手教会你👊！</p><p>⭐上面只说了项目的主要功能以及需要实现的相关技术，却没有涉及一个关键的点，那就是天气的信息该怎么获取，这个不用担心，已经有大佬为你做好了，你只需要会调用就行了。</p><p>本篇博客以彩云天气为例，简单介绍如何获得彩云天气的API。</p><p>🍃首先登录<a href="https://dashboard.caiyunapp.com/">彩云天气</a>官网注册：<a href="https://dashboard.caiyunapp.com/">https://dashboard.caiyunapp.com/</a></p><p>🍃注册完了以后，申请令牌（<strong>重要</strong>），这里还需要让你填写应用链接，由于还没有创建，可以先不填。</p><p>🍃拿到令牌以后就可以使用彩云天气提供的各种API接口了。</p><h1 id="二、Git代码托管"><a href="#二、Git代码托管" class="headerlink" title="二、Git代码托管"></a>二、Git代码托管</h1><p>⭐这里就对Git就不介绍了，毕竟你都能看见我的博客，那你肯定也略知一二，我自己其实也不够了解没什么发言权。好了进入正题，首先你需要有一个Git账号，然后新建一个仓库（Repository），不需要勾选其他的东西，默认就行了，然后点击Create repository按钮就创建成功了。</p><p>🍌接下来就需要创建项目了，在Android studio中新建一个Kotlin项目，创建完需要去将仓库的远程版本库克隆到本地，将仓库的版本库中的Https复制一份，然后打卡cmd，进入你这个项目的目录下，输入git clone （这里是你项目仓库的Https），克隆成功需要做一件事情，那就是将SunnyWeather项目中的文件都复制到上一层目录，这样做的目的：可以将整个项目工程目录添加到版本控制中去，这里有个坑，在这些文件里面有一个隐藏文件（.git），需要你文件夹设置一下才能看见这些隐藏的文件，把所有的文件复制到上一层的时候会有一个文件.gitignote文件，直接覆盖就好，复制完将SunnyWeather文件夹删除。哈哈可能你会觉得有点麻烦，没办法，我一开始接触的时候也觉得麻烦，因为对计算机这些指令不熟悉很陌生，不过没关系，以后就会习惯了。最后，将SunnyWeather项目中的文件提交到Github上面。</p><p>具体指令如下(接着上面的操作继续)：</p><p>🍍git add .         添加操作</p><p>🍍git commit -m “（这里可以描述你这次提交代码的简单说明，比如：First commit）”</p><p>🍍git push origin main</p><p>👁到这一步完成就成功的实现了Git代码托管。</p><h1 id="三、搭建MVVM项目框架"><a href="#三、搭建MVVM项目框架" class="headerlink" title="三、搭建MVVM项目框架"></a>三、搭建MVVM项目框架</h1><p>⭐由于这是我第一次搭建MVVM项目框架加上自己本身对MVVM也不够了解，我就不展开介绍了，详细可以看这个<a href="https://blog.csdn.net/lmq121210/article/details/80872652?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166306818616782391895448%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166306818616782391895448&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-7-80872652-null-null.142%5Ev47%5Epc_rank_34_1,201%5Ev3%5Econtrol&utm_term=%E5%AE%89%E5%8D%93mvvm%E6%A1%86%E6%9E%B6&spm=1018.2226.3001.4187">大佬的文章</a>，我们的项目需要严格按照MVVM项目框架进行搭建。在你的项目的包下新建几个包，项目结构如下图所示。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913192832.png"></p><p>图中的logic包用于存放业务逻辑相关的代码，ui包用于存放页面展示相关的代码，而logic包下的dao、mode、network分别用于存放数据访问对象、对象模型以及网络相关的代码，ui包下的place和weather则是SunnyWeather中的两个主要界面。由于这些操作会涉及网络和对象存储等操作，需要导包，编辑app/build.gradle文件，如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913193511.png"></p><h1 id="四、搜索全球城市数据"><a href="#四、搜索全球城市数据" class="headerlink" title="四、搜索全球城市数据"></a>四、搜索全球城市数据</h1><p>⭐在开始写代码之前，我们可以先准备一些方便后期编程的一些工具类，这里需要写一样获得全局Context的工具类，并且将令牌配置在这里面。在你的项目的包下，新建一个SunnyWeatherApplycation类，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194107.png"></p><p>红色箭头所指填你申请到的令牌~</p><p>然后我们还需要在AndroidManifest.xml文件中更改android：name指定的内容，改为.SunnyWeatherApplication。</p><p>根据彩云天气的API文档，接下来我们开始定义相关的数据模型。</p><p>⭐在logic/model包下新建PlaceResponse.kt文件,并在这个文件中编写如下代码：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194417.png"></p><p>⭐接着定义彩云天气测试搜索API的Retrofit接口，在logic/network包下新建PlaceService接口，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194620.png"></p><p>⭐定义好了PlaceSertvice接口，我们需要使用它的前提得需要有一个Retrofir构建器，在logic/network包下新建一个ServiceCreator单例类，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194907.png"></p><p>⭐然后我们需要再定义一个统一的网络数据源访问入口，对所有散落请求的API进行封装。同样在logic/network包下新建一个SunnyWeatherNetwork单例类，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195230.png"></p><p>⭐另外我们需要在logic包下新建一个Repository单例类，这是仓库层的统一封装入口，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195543.png"></p><p>⭐到这里，逻辑层的实现就只剩最后一步了，定义ViewModel层，这里对ViewModel层解释一下，它相当于逻辑层和UI层的一个桥梁，虽然它更偏向于逻辑层。在ui/place包下新建一个PlaceViewModel，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195904.png"></p><p>🍉由于作者很懒，就不进行详细讲解了，天气的UI层代码以及RecyclerView的适配器和展示天气的PlaceFragment可以去我仓库clone查看，我就不在码字了，我的<a href="https://github.com/Crwei996/SunnyWeather">Github</a>，仓库名字即SunnyWeather。</p><p>注意：由于PlaceFragment中实现了一个搜索框布局，需要修改原生的ActionBar，修改res/values/theme.xml中的代码</p><p>改成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;style name=<span class="hljs-string">&quot;Theme.SunnyWeather&quot;</span> parent=<span class="hljs-string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>最后别忘记添加网络权限，AndroidManifest.xml文件中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;uses-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>完成这些就可以实现全球城市的搜索了，可以看我的Demo，这里不多放图了。</p><p>好了，关于城市搜索这块的代码就先写到这，现在提交代码到Github中去。</p><p>🍃git add .         添加操作</p><p>🍃git commit -m “（这里可以描述你这次提交代码的简单说明，比如：实现搜索全球城市数据功能）”</p><p>🍃git push origin main </p><h1 id="五、显示天气信息"><a href="#五、显示天气信息" class="headerlink" title="五、显示天气信息"></a>五、显示天气信息</h1><p>这一部分的逻辑和实现全球城市的搜索类似，根据API天气信息接口返回的JSON数据进行解析，具体操作如下：</p><p>⭐首先建立数据模型，在logic/model包下新建DailyResponse.kt文件，代码如下：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913202821.png"></p><p>🥥接着定义一个用于访问天气API的Retrofit接口，在logic/network包下新建WeatherService接口，代码如下：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203128.png"></p><p>⚡在SunnyWeatherNetwork这个网络数据源访问入口对新增的WeatherService接口进行封装，添加如下代码到SunnyWeatherNetwork：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203431.png"></p><p>💧完成了网络层的代码编写，和之前一样，创建仓库层，不过前面已经创建仓库层Repository了，在Repository中添加如下代码：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203625.png"></p><p>🍇到这逻辑层就只剩最后一步了，定义ViewModel层，在ui/weather包下新建一个WeatherViewModel，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203856.png"></p><p>⚽又到了我要偷懒的UI层了，和上面的ui层一样去我仓库clone项目自己去看把，我手敲的好累。</p><p>📕天气的页面布局完成以后，我们还需要一个转换函数，将获得到的天气代码转成一个Sky对象，为什么要这样，因为返回的数据是这样的…哈哈哈哈，在logic/model包下新建一个Sky.kt文件，代码如下所示：（这里太长了就不截图了，截图截不全）</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tp">class Sky(val info:String,val icon:Int,val bg:Int)<br>private val sky = mapOf(<br>    <span class="hljs-string">&quot;CLEAR_DAY&quot;</span> to Sky(<span class="hljs-string">&quot;晴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;CLEAR_NIGHT&quot;</span> to Sky(<span class="hljs-string">&quot;晴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;PARTLY_CLOUDY_DAY&quot;</span> to Sky(<span class="hljs-string">&quot;多云&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;PARTLY_CLOUDY_NIGHT&quot;</span> to Sky(<span class="hljs-string">&quot;多云&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;CLOUDY&quot;</span> to Sky(<span class="hljs-string">&quot;阴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;WINDY&quot;</span> to Sky(<span class="hljs-string">&quot;大风&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;LIGHT_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;小雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;MODERATE_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;中雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;HEAVY_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;大雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;STORM_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;暴雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;THUNDER_SHOWER&quot;</span> to Sky(<span class="hljs-string">&quot;雷阵雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;SLEET&quot;</span> to Sky(<span class="hljs-string">&quot;雨夹雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;LIGHT_SHOW&quot;</span> to Sky(<span class="hljs-string">&quot;小雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;MODERATE_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;中雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HEAVY_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;大雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;STORM_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;暴雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HAIL&quot;</span> to Sky(<span class="hljs-string">&quot;冰雹&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;LIGHT_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;轻度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;MODERATE_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;重度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HEAVY_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;重度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;FOG&quot;</span> to Sky(<span class="hljs-string">&quot;雾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;DUST&quot;</span> to Sky(<span class="hljs-string">&quot;浮尘&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img)<br><br>    )<br>fun getSky(skycon:String):Sky&#123;<br>    return sky[skycon] ?:sky[<span class="hljs-string">&quot;CLEAR_DAY&quot;</span>]<span class="hljs-comment">!!</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>由于省事，我就没有给相应的天气设置相应的背景图和图标了，你有兴趣的话可以自己去找图片和图标添加，关于天气自定义图标添加可以去看我在csdn写的一篇博客☞<a href="https://blog.csdn.net/qq_60387902/article/details/126664727?spm=1001.2014.3001.5501">Android studio使用阿里巴巴图标矢量图库</a>！</p><h1 id="六、手动刷新天气和切换城市"><a href="#六、手动刷新天气和切换城市" class="headerlink" title="六、手动刷新天气和切换城市"></a>六、手动刷新天气和切换城市</h1><p>☀手动刷新天气简单，这里就不详细说了，使用一个SwipeRefreshLayout布局就行，详细步骤看我的项目demo，里面很详细。</p><p>🌙切换城市也是一个DrawerLayout布局的事情，也不细说了，看demo。需要注意的是，在侧滑菜单消失以后记得隐藏输入法，你可以试试不隐藏输入法时的效果，在DrawerLayout的监听里实现相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">drawerLayout.addDrawerListener(object :DrawerLayout.DrawerListener&#123;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerSlide</span><span class="hljs-params">(drawerView: View, slideOffset: Float)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerOpened</span><span class="hljs-params">(drawerView: View)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;ServiceCast&quot;)</span><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerClosed</span><span class="hljs-params">(drawerView: View)</span> </span>&#123;<br>        <span class="hljs-comment">//因为弹出这个滑动菜单以后，如果想输入新的地址会弹出一个输入法，如果在你输完以后直接就关闭滑动菜单的话需要把输入法也关闭</span><br>        <span class="hljs-comment">//关闭弹出的输入法</span><br>        val manager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager<br>        manager.hideSoftInputFromWindow(drawerView.windowToken,InputMethodManager.HIDE_NOT_ALWAYS)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerStateChanged</span><span class="hljs-params">(newState: Int)</span> </span>&#123;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最后一个阶段的开发任务也完成了，记得提交代码</p><p>🍓git add .         添加操作</p><p>🍓git commit -m “（这里可以描述你这次提交代码的简单说明，比如：新增切换城市和手动更新天气的功能）”</p><p>🍓git push origin main </p><h1 id="七、项目提升"><a href="#七、项目提升" class="headerlink" title="七、项目提升"></a>七、项目提升</h1><p>这个项目我是根据郭霖的《第一行代码》写的，我的demo过于简陋，很多能简单的就简单，以及一些ui可能你会觉得好丑或者什么，你可以自行修改；或者说你觉得天气显示的太少了或者不够精美不够详细，你也可以根据彩云天气的API自行修改……终于敲完了，好累好累好累！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913205647.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
