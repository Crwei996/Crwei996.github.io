<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android初探建造者模式</title>
    <link href="/2023/09/19/Android%E5%88%9D%E6%8E%A2%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/19/Android%E5%88%9D%E6%8E%A2%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、建造者模式"><a href="#一、建造者模式" class="headerlink" title="一、建造者模式"></a>一、建造者模式</h1><p>定义：</p><p>构建者模式（Builder Pattern）是一种创建型设计模式，旨在通过提供一种灵活的方式来构建复杂对象。该模式将对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。</p><p>具体来说，构建者模式使用一个独立的构建器（Builder）类来封装对象的构建过程。构建器类提供一系列方法来设置对象的属性，并最终返回构建好的对象。这种方式可以避免使用多个构造函数或过多的参数，使得对象的构建过程更加直观和易于扩展。</p><p>生活中的例子：</p><p>假设你要建造一座房子，房子有多个组成部分，例如墙壁、门、窗户等。使用构建者模式可以将建造房子的过程分解为以下步骤：</p><p>创建一个房子构建器类（HouseBuilder），该类负责构建房子对象。<br>在房子构建器类中定义一系列方法，例如 buildWalls()、buildDoors()、buildWindows() 等，用于设置房子的各个组成部分。<br>客户端代码创建一个房子构建器对象，并使用该对象调用相应的方法来设置房子的属性，例如设置墙壁类型、设置门的数量、设置窗户的尺寸等。<br>最后，房子构建器对象调用 build() 方法返回构建好的房子对象。<br>使用构建者模式，在不同的场景下可以定制化构建不同类型的房子，而且可以灵活地添加或修改构建过程中的步骤。</p><p>总结一下，构建者模式通过将复杂对象的构建过程与其表示分离，提供了一种灵活且可扩展的方式来构建对象。</p><h1 id="二、建造者模式作用"><a href="#二、建造者模式作用" class="headerlink" title="二、建造者模式作用"></a>二、建造者模式作用</h1><p>建造者模式是一种创建型设计模式，主要用于构建复杂对象。它的作用是将对象的创建过程与表示分离，以便可以使用相同的构建过程来创建不同的表示。</p><p>具体来说，建造者模式的作用如下：</p><p>封装复杂对象的创建过程：建造者模式将复杂对象的构建过程封装在具体建造者中，客户端无需知道对象的具体创建细节，只需要通过指挥者或者具体建造者来完成对象的构建。</p><p>提供灵活的构建流程：建造者模式允许客户端通过不同的组合方式来构建对象，从而灵活地生成不同的表示。客户端可以根据需求自由选择具体建造者，并按照需要调用建造者的方法来设置对象的属性。</p><p>支持逐步构建复杂对象：通过建造者模式，可以逐步构建复杂对象，每一步都可以通过建造者的方法来设置对象的属性，最终调用建造者的方法返回构建好的对象。这种逐步构建的方式对于某些复杂对象的构建非常有帮助。</p><p>避免构造方法参数过多：对于具有大量属性的对象，如果使用构造方法来创建对象，会出现参数过多、参数顺序困扰等问题。而建造者模式通过链式调用设置属性，避免了构造方法参数过多的问题，使得代码更加清晰易读。</p><p>支持对象属性的变化：如果一个对象的属性有较高的变动性，使用建造者模式可以很方便地修改具体建造者的实现，而无需修改客户端的代码。这样可以降低耦合度，提高系统的可维护性和可扩展性。</p><p>总而言之，建造者模式将复杂对象的创建过程封装起来，提供灵活的构建流程，以及逐步构建复杂对象的能力，同时避免了构造方法参数过多的问题，支持对象属性的变化。它能够帮助我们更好地组织和管理复杂对象的创建，提高代码的可读性、可维护性和可扩展性。</p><h1 id="三、建造者模式案例"><a href="#三、建造者模式案例" class="headerlink" title="三、建造者模式案例"></a>三、建造者模式案例</h1><p>下面是我自己本人在csdn上学习他人博客写的一个小案例，如有错误欢迎指出，自己也是第一次学习建造者模式，还存在很多很多不懂之处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.example.constraintlayoutlearning;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> Crwei</span><br><span class="hljs-comment"> * date 2023/9/18 19:48</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestPerson</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String mPersonName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mPersonAge;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mSex;<br>    <span class="hljs-keyword">private</span> String mCardNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getmPersonName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mPersonName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getmPersonAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mPersonAge;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestPerson</span><span class="hljs-params">(TestPerson.Builder builder)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.mCardNumber = builder.mCardNumber;<br>        <span class="hljs-keyword">this</span>.mSex = builder.mSex;<br>        <span class="hljs-keyword">this</span>.mPersonAge = builder.mPersonAge;<br>        <span class="hljs-keyword">this</span>.mPersonName = builder.mPersonName;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.mPersonAge&gt;<span class="hljs-number">100</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;年龄不能超过100&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String mPersonName;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mPersonAge;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mSex;<br>        <span class="hljs-keyword">private</span> String mCardNumber;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> TestPerson <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestPerson(<span class="hljs-keyword">this</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> TestPerson.<span class="hljs-function">Builder <span class="hljs-title">addPersonName</span><span class="hljs-params">(String mPersonName)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.mPersonName = mPersonName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> TestPerson.<span class="hljs-function">Builder <span class="hljs-title">addPersonAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mPersonAge)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.mPersonAge = mPersonAge;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> TestPerson.<span class="hljs-function">Builder <span class="hljs-title">addSex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mSex)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.mSex = mSex;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">public</span> TestPerson.<span class="hljs-function">Builder <span class="hljs-title">addCardNumber</span><span class="hljs-params">(String mCardNumber)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.mCardNumber = mCardNumber;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里对TestPerson类使用了构建者模式，该类的建立参考来源 。</p><p>从上面可以看到，除了mPersonName是用public修饰的，其余都是private，为什么要用public以及对这个属性设置了两个ge方法，这和我使用Databing有关，这里我们等会说，一般都是使用private（而且还可以加final修饰）。</p><p>定义完基本的属性以后，我们在下面定义了一个用final实现的抽象类Builder，这样做的目的是为了避免在子类中修改build方法，以保持整个类的稳定性和一致性，同时也可以提高性能，因为final修饰会在编译的时候被内联优化。在Builder中我们又定义了和TestPerson相同的属性，这些属性的修饰符都是private。然后我们提供了大量的方法来set Builder中的属性值，并且将其赋值给调用者。</p><p>使用方法：</p><pre><code class="hljs">    try&#123;        person = new TestPerson.Builder()                .addPersonName(&quot;张三&quot;)                .addSex(1)                .addPersonAge(122)                .build();    &#125;catch (IllegalArgumentException e)&#123;        System.out.println(e.getMessage());    &#125;</code></pre><p> 可能有人问，这里为什么要用try-catch，注意看上面代码的这一部分</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> TestPerson(TestPerson.Builder builder)&#123;<br>    <span class="hljs-keyword">this</span>.mCardNumber = builder.mCardNumber;<br>    <span class="hljs-keyword">this</span>.mSex = builder.mSex;<br>    <span class="hljs-keyword">this</span>.mPersonAge = builder.mPersonAge;<br>    <span class="hljs-keyword">this</span>.mPersonName = builder.mPersonName;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.mPersonAge&gt;<span class="hljs-number">100</span>)&#123;<br>        <span class="hljs-keyword">throw</span> new IllegalArgumentException(<span class="hljs-string">&quot;年龄不能超过100&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们对这个属性做了一个限制，因为我们实际使用的时候，肯定会有一些属性有所限制，我们可以直接在这里就对限制做了处理，然后在Builder的时候使用try-catch捕获异常，可以更方便的知道数据是否存在问题。</p><p>上面的代码虽然使用了建造者模式，但是还是可以优化的，有一个插件叫Lombok，使用该插件可以减少TestPerson的大量代码，我还没有用过，我就不介绍了，有兴趣的朋友可以自行研究。</p><h1 id="四、建造者模式的使用场景"><a href="#四、建造者模式的使用场景" class="headerlink" title="四、建造者模式的使用场景"></a>四、建造者模式的使用场景</h1><p>创建复杂对象：当需要创建一个带有多个属性并且初始化过程较为复杂的对象时，可以使用建造者模式。通过逐步设置对象的属性，并在最后一步构建对象，能够简化对象的创建过程。</p><p>需要灵活组合对象属性：建造者模式能够根据需要选择性地设置对象的属性。可以按照不同的需求组合不同的属性，而无需创建多个独立的构造函数或使用大量的可选参数。</p><p>避免重叠构造器问题：当一个类的属性较多，存在多种组合方式时，使用传统的多个构造函数容易造成构造器重叠问题。而建造者模式可以通过链式调用的方式避免这个问题，并使代码更加清晰易读。</p><p>支持不可变对象构建：建造者模式可以创建不可变对象，即对象一旦创建就不能再修改其属性值。通过在Builder类中将对象的属性设置为final，并在build方法中创建不可变对象，可以确保对象的属性值在创建后不会被修改。</p><p>便于扩展：如果需要为已有的对象添加新的属性，或者需要创建该类的子类，使用建造者模式能够方便地进行扩展和修改。</p><p>总的来说，建造者模式适用于需要创建复杂对象，并且需要对对象属性进行灵活组合和控制的场景。它能够提高代码的可读性、可维护性和可扩展性。</p><p>像我们使用的Okhttp以及一些dialog里面大部分都是使用的建造者模式的，使用建造者模式可以让使用者更方便灵活的使用他们。</p><h1 id="五、一些思考"><a href="#五、一些思考" class="headerlink" title="五、一些思考"></a>五、一些思考</h1><p>我在学习建造者模式的时候是和databing一起使用的，在使用的过程中我发现，当TestPerson的属性都是private的时候，我在xml中这样使用是不可以的，无法获取到对象的值，当我将该属性的值的修饰符从private改成public的时候就可以获取到了，我很不解。</p><p>只有把mPersonName的修饰符改成public才行，如果有更好的方案实现或者其他方法评论区交流，目前本人刚学，刚刚入门建造者模式。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20230919164157.png"></p><p>我以为是private在建造者模式里面无法通过get拿到值，但是我在activity or fragment中又可以拿到值。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/img20230919164248.png"></p><p>这里又可以拿到另外一个private修饰的属性的值，我不理解。</p><p>后面还会进行更新本文，今天是对建造者模式的初步了解，还有很多不会的地方，学生所做，如有写错，敬请批评指正。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国产CPU科普</title>
    <link href="/2023/04/12/%E5%9B%BD%E4%BA%A7CPU%E7%A7%91%E6%99%AE/"/>
    <url>/2023/04/12/%E5%9B%BD%E4%BA%A7CPU%E7%A7%91%E6%99%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、国产CPU种类"><a href="#一、国产CPU种类" class="headerlink" title="一、国产CPU种类"></a>一、国产CPU种类</h1><table><thead><tr><th></th><th align="center">海光</th><th align="center">兆芯</th><th align="center">飞腾</th><th align="center">鲲鹏</th><th align="center">倚天710</th><th align="center">申威</th><th align="center">龙芯</th></tr></thead><tbody><tr><td>研发单位</td><td align="center">海光信息</td><td align="center">上海兆芯</td><td align="center">天津飞腾</td><td align="center">海思华为</td><td align="center">平头哥</td><td align="center">申威科技</td><td align="center">龙芯中科</td></tr><tr><td>团队背景</td><td align="center">X86授权+自研</td><td align="center">X86/ARM授权</td><td align="center">SPARC/ARM授权+自研</td><td align="center">ARM授权+自研</td><td align="center">ARM授权+自研</td><td align="center">江南计算所</td><td align="center">中科院计算机所</td></tr><tr><td>指令集体系来源</td><td align="center">X86授权+自研</td><td align="center">X86/ARM授权</td><td align="center">SPARC/ARM授权+自研</td><td align="center">ARM授权+自研</td><td align="center">ARM授权＋自研</td><td align="center">Alpha授权+自研</td><td align="center">MIPS授权+自研</td></tr><tr><td>应用领域</td><td align="center">Zen1架构，性能较强，应用生态丰富</td><td align="center">上海地区覆盖广，X86应用生态丰富</td><td align="center">产品起步晚，性能相对弱势，被美国制裁中</td><td align="center">ARM前景广阔：产品线丰富，性能不断提高；架构层级授权自主化程度较高</td><td align="center">ARM前景广阔，性能较强，有阿里云作为生态铺垫，前景较好</td><td align="center">在军方市场占有率高，底层应用、超算为主力方向</td><td align="center">自主化程度高，市场受成都考量</td></tr><tr><td>优势</td><td align="center">Zen1架构，性能较强，应用生态丰富</td><td align="center">上海地区覆盖广，X86应用生态丰富</td><td align="center">ARM前景广阔；产品线丰富，性能不断提升；架构层级授权自主化程度较高</td><td align="center">ARM前景广阔；产品线极其丰富，起步早，适配厂商多，能力最强</td><td align="center">ARM前景广阔，性能较强，有阿里云作为生态铺垫，前景较好</td><td align="center">在军方市场占有率较高，底层应用、超算为主力方向</td><td align="center">自主化程度高，市场还有待考量</td></tr><tr><td>劣势</td><td align="center">仅内核层级授权，自主化程度低；无桌面授权，收美国制裁中</td><td align="center">早期的X86内核层级授权，市场开拓不足</td><td align="center">产品起步晚，性能相对弱势，被美国制裁中</td><td align="center">受制裁中，未来存在不确定性</td><td align="center">阿里云目前难以在党政中获得竞争力</td><td align="center">超算为主要方向，商用产品开发不足，受美国制裁中</td><td align="center">MIPS生态应用匮乏、性能一般，不利用商用市场拓展</td></tr><tr><td>相关产品</td><td align="center">海光3000/5000/7000</td><td align="center">ZX-C/ZX-D/KX5000/KX6000/KH-20000/30000</td><td align="center">腾云S系列/鲲鹏D系列</td><td align="center">鲲鹏系列</td><td align="center">倚天710</td><td align="center">SW-1600/SW1610/SW</td><td align="center">龙芯1号/龙芯2号/龙芯3号</td></tr><tr><td>产品覆盖领域</td><td align="center">服务器</td><td align="center">嵌入式、服务器、桌面</td><td align="center">服务器、桌面、嵌入式</td><td align="center">服务器、桌面、嵌入式</td><td align="center">服务器</td><td align="center">服务器、桌面</td><td align="center">桌面、服务器、嵌入式</td></tr><tr><td>实际应用</td><td align="center">国家级超算</td><td align="center">联想笔记本、服务器、火星舱存储系统</td><td align="center">天河一号/天河二号/天河三号</td><td align="center">华为服务器、台式机</td><td align="center">阿里云服务器</td><td align="center">神威蓝光、神威·太湖之光</td><td align="center">玲珑/逸珑/福珑北斗导航卫星</td></tr></tbody></table><h1 id="后面发现不好用博客展示于是还是用PPT写了哈哈哈哈烂尾楼咯"><a href="#后面发现不好用博客展示于是还是用PPT写了哈哈哈哈烂尾楼咯" class="headerlink" title="后面发现不好用博客展示于是还是用PPT写了哈哈哈哈烂尾楼咯"></a>后面发现不好用博客展示于是还是用PPT写了哈哈哈哈烂尾楼咯</h1>]]></content>
    
    
    <categories>
      
      <category>课堂展示</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学科学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记-第五章-链路层以及局域网</title>
    <link href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221017181046.png"></p><p>[TOC]</p><p>没写完……..不想写了。</p><h1 id="一、引论和服务"><a href="#一、引论和服务" class="headerlink" title="一、引论和服务"></a>一、引论和服务</h1><ul><li>一些术语介绍：主机和路由器是节点（网桥和交换机也是）：nodes</li><li>沿着通信路径,连接个相邻节 点通信信道的是链路：links<ul><li>有线链路</li><li>无限链路</li><li>局域网，共享性链路</li></ul></li><li>第二层协议数据单元帧frame，封装数据报</li><li><strong>数据链路层负责从一个节点通过链路将 （帧中的）数据报发送到相邻的物理节点 （一个子网内部的2节点）</strong></li><li><strong>点到点链路的链路层服务 实现非常简单，封装和解封装</strong></li><li><strong>WAN——广域网（采用点到点链路）</strong><ul><li>带宽大、距离远（延迟大）</li><li>如果采用多点连接方式<ul><li>竞争方式：一旦冲突代价大</li><li> 令牌等协调方式：在其中协调节点的发送代价大</li></ul></li></ul></li><li><strong>LAN——局域网（采用多点连接方式）</strong><ul><li> 连接节点非常方便</li><li>接到共享型介质上（或网络交换机），就可以连接所有其他节点</li></ul></li><li><strong>多点连接方式网络的链路层 功能实现相当复杂</strong><ul><li>多点接入：协调各节点对共享性介质的访问和使用</li><li>竞争方式：冲突之后的协调</li><li>令牌方式：令牌产生，占有和释放等</li></ul></li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018155801.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018155811.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018155820.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018155834.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018155847.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018155853.png"></p><p><strong>“ rdt(reliable data transfer protocol,可靠数据传输协议)”</strong></p><h1 id="二、差错检测和纠正"><a href="#二、差错检测和纠正" class="headerlink" title="二、差错检测和纠正"></a>二、差错检测和纠正</h1><p><strong>比特差错</strong>：比特在传输过程中可能会产生差错，从1变成0，也可能从0变成1，这就叫比特差错。</p><p><strong>误码率BER（Bit Error Rate）</strong>:在一段传输时间内，传输错误的比特占所传输的比特总数的比率就叫做误码率。</p><p><strong>模二运算</strong>：在进行循环冗余检测CRC的时候会使用到模二运算，运算规则:二进制数进行运算时不进位。</p><p>例如：1111+1010 = 0101。减法和加法一样，按减法规则计算。</p><p><strong>循环冗余检验CRC</strong>：<a href="https://blog.csdn.net/liyuanbhu/article/details/7882789?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166608125216782391813808%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166608125216782391813808&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-7882789-null-null.142%5Ev58%5Econtrol,201%5Ev3%5Eadd_ask&utm_term=%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C&spm=1018.2226.3001.4187">这里的话我用几句话说不清楚，我也是刚学这个知识点，想了解明白可以看这篇博客。</a>在接收端把接收到的数据以帧为单位进行CRC检验，把收到的每一个帧都除以同样的除数P(模2原算的结果)，然后检查得到的余数R。如果在传输过程中没有差错，那么结果CRC检验后得出的余数R肯定是0，如果不是0，那么就说明在传输过程中出现的差错。</p><p>若得出的余数R为0，则判断这个帧没有差错，就接受。</p><p>若R不为0，则判断这个帧有差错，如果无法确定究竟是哪一位或者哪几位出现了差错就会选择丢弃这个帧。</p><p><strong>强调：</strong>在数据链路层仅仅使用循环冗余检验CRC差错检验技术，则只能做到对帧的<strong>无差错接受</strong>，即<strong>凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错。</strong>接收端丢弃的帧虽然<strong>曾收到了</strong>，但最终还是因为有差错<strong>被丢弃</strong>，即没有接受。<strong>通常认为，凡是接受端数据链路层接受的帧均无差错。</strong></p><p><u><strong>在数链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输！！！</strong></u></p><h1 id="三、多点访问协议"><a href="#三、多点访问协议" class="headerlink" title="三、多点访问协议"></a>三、多点访问协议</h1><p>多路访问链路和协议</p><p>两种类型的链路（一个子网内部链路连接形式）：点对点和广播 (共享线路或媒体)。</p><ul><li>点对点<ul><li>拨号访问的PPP</li><li>以太网交换机和主机之间的点对点链路</li></ul></li><li>广播<ul><li>传统以太网</li><li> HFC上行链路</li><li> 802.11无线局域网</li></ul></li></ul><p><strong>多路访问协议</strong></p><ul><li>单个共享的广播型链路</li><li>2个或更多站点同时传送: 冲突（collision）<ul><li> 多个节点在同一个时刻发送，则会收到2个或多个信号叠加</li></ul></li><li>MAC（媒体访问控制）协议：分类<ul><li>信道划分<ul><li>把信道划分成小片（时间、频率、编码）</li><li>分配片给每个节点专用</li></ul></li><li> 随机访问</li><li>信道不划分，允许冲突</li><li>冲突后恢复</li><li>依次轮流<ul><li>节点依次轮流</li><li> 但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul></li></ul><p>啊啊啊啊，不想写了，贴图，后面的就不写了，感觉自己看了这一章的视频学到的东西不多，这一块建议看书。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018164933.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018164940.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165159.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165309.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165336.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165351.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165504.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165517.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165558.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165616.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165631.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165647.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165736.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165812.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221018165853.png"></p><p>不想再贴图了，没意思…</p><h1 id="四、Lans"><a href="#四、Lans" class="headerlink" title="四、Lans"></a>四、Lans</h1><h2 id="一-、addressing，ARP"><a href="#一-、addressing，ARP" class="headerlink" title="(一)、addressing，ARP"></a>(一)、addressing，ARP</h2><h2 id="二-、Ethernet"><a href="#二-、Ethernet" class="headerlink" title="(二)、Ethernet"></a>(二)、Ethernet</h2><h2 id="三-、802-11WLAN"><a href="#三-、802-11WLAN" class="headerlink" title="(三)、802.11WLAN"></a>(三)、802.11WLAN</h2><h2 id="四-、switches"><a href="#四-、switches" class="headerlink" title="(四)、switches"></a>(四)、switches</h2><h2 id="五-、VLANS"><a href="#五-、VLANS" class="headerlink" title="(五)、VLANS"></a>(五)、VLANS</h2><h1 id="五、链路虚拟化：MPLS"><a href="#五、链路虚拟化：MPLS" class="headerlink" title="五、链路虚拟化：MPLS"></a>五、链路虚拟化：MPLS</h1><h1 id="六、数据中心网络"><a href="#六、数据中心网络" class="headerlink" title="六、数据中心网络"></a>六、数据中心网络</h1><h1 id="七、a-day-in-the-life-of-web-request"><a href="#七、a-day-in-the-life-of-web-request" class="headerlink" title="七、a day in the life of web request"></a>七、a day in the life of web request</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记-第四章-网络层</title>
    <link href="/2022/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2022/10/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013113552.png"></p><p>[TOC]</p><h1 id="一、导论"><a href="#一、导论" class="headerlink" title="一、导论"></a>一、导论</h1><p>网络层服务：</p><ul><li>在发送主机和接收主机对之间传送段（segment）</li><li>在发送端将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于每一个主机和路由器</li><li>路由器检查每一个经过它的IP数据报的头部</li></ul><p>网络层关键功能：</p><ul><li>转发：将分组从路由器的输入接口转发到合适的输出接口</li><li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径<ul><li>路由选择算法</li><li>路由选择协议（RIP，OSPF,BGP）</li></ul></li><li>转发是通过单个路口的过程</li><li>路由是从源到目的的路由规划过程</li></ul><h2 id="一-网络层：数据平面"><a href="#一-网络层：数据平面" class="headerlink" title="(一)网络层：数据平面"></a>(一)网络层：数据平面</h2><p>数据平面：决定从路由器输入端口到达的分组如何转发到输出端口</p><p>转发方式：</p><p>传统方式：基于目标地址+转发表（控制平面：路由算法决定端到端的路径，数据平面：IP协议根据转发表决定了IP数据报在此路由器上的局部转发）</p><p>SDN方式：基于多个字段+流表</p><h2 id="二-网络层：控制平面"><a href="#二-网络层：控制平面" class="headerlink" title="(二)网络层：控制平面"></a>(二)网络层：控制平面</h2><p>控制平面：决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</p><p>两个控制方面方法：</p><p>传统的路由算法：在路由器中被实现（分布式）</p><p>SDN：在远程的服务器中实现（集中式）</p><p>网络服务模型：</p><p>问：从发送方主机到接收方主机传输数据报的“通道” ，网络提供什么样的服务模型？</p><p>对于单个数据报的服务：可靠传输+延迟保证（例如 少于40ms的延迟）</p><p>对于数据报流的服务：保序数据报传送+保证流的最小带宽+分组之间的延迟差</p><h1 id="二、路由器组成"><a href="#二、路由器组成" class="headerlink" title="二、路由器组成"></a>二、路由器组成</h1><h2 id="一-路由器结构概述"><a href="#一-路由器结构概述" class="headerlink" title="(一)路由器结构概述"></a>(一)路由器结构概述</h2><p>看书。</p><h2 id="二-输入端口功能"><a href="#二-输入端口功能" class="headerlink" title="(二)输入端口功能"></a>(二)输入端口功能</h2><p>根据数据报头部的信息：目的地址在输入端口缓存中的转发表中查找合适的输出端口（匹配+行动）</p><p>基于目标的转发：仅仅依赖于IP数据报的目标IP地址（传统方法）</p><p>通用转发：基于头部字段的任意集合进行转发</p><h2 id="三-最长前缀匹配"><a href="#三-最长前缀匹配" class="headerlink" title="(三)最长前缀匹配"></a>(三)最长前缀匹配</h2><p>当给定目标地址转发表时，采用最长地址前缀匹配的目标地址表项</p><p>最长前缀匹配：在路由器中经常采用TCAMs( ternary content addressable memories)硬件来完成</p><p>作用：方便查询路由表，提高效率</p><h2 id="四-输入端口缓存"><a href="#四-输入端口缓存" class="headerlink" title="(四)输入端口缓存"></a>(四)输入端口缓存</h2><p>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队-&gt;排队延时-&gt;输入缓存溢出-&gt;数据丢失</p><h2 id="五-交换结构"><a href="#五-交换结构" class="headerlink" title="(五)交换结构"></a>(五)交换结构</h2><p>将分组从输入缓冲区传输到合适的输出端口</p><p>交换速率：分组可以按照该速率从输入传输到输出</p><p>说明：此次的运行速度是输入/输出链路速率的若干倍，例如N个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈</p><p>三种典型交换结构：memory  bus crossbar</p><p>memory：</p><ul><li>在CPU直接控制下的交换，采用传统的计算机</li><li>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li><li>转发速率被内存的带宽限制 (数据报通过BUS两遍)</li><li>一次只能转发一个分组</li></ul><p>bus：</p><ul><li>数据报通过共享总线，从输入端口转发到输出端口</li><li>总线竞争: 交换速度受限于总线带宽</li><li>1次处理一个分组</li><li>1 Gbps bus, Cisco 1900； 32 Gbps bus, Cisco 5600；对于接入或企业级路由器，速度足够（但不适合区域或骨干网络）</li><li>数据报通过BUS一遍</li></ul><p>crossbar：</p><ul><li>同时并发转发多个分组，克服总线带宽限制</li><li>Banyan（榕树）网络，crossbar(纵横) 和其它的互联网络被开发，将多个处理器连接成多处理器</li><li>当分组从端口A到达，转给端口Y；控制器短接相应的两个总线</li><li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li><li>Cisco12000：以60Gbps的交换速率通过互联网络</li></ul><h2 id="六-输出端口"><a href="#六-输出端口" class="headerlink" title="(六)输出端口"></a>(六)输出端口</h2><p>不是所有的数据报（分组）都能成功从输出端口输出，因为会存在数据报丢失的情况，由于拥塞，缓存区没有空间。</p><ol><li>当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存</li><li>由调度规则选择排队的数据报进行传输</li><li>输出端口排队</li></ol><h2 id="七-调度机制"><a href="#七-调度机制" class="headerlink" title="(七)调度机制"></a>(七)调度机制</h2><p>调度即选择下一个要通过链路传输的分组</p><p>调度方式：</p><p>FIFO（队列 先到先得）</p><p>丢弃策略:如果分组到达一个满的队列，哪个分组将会被抛弃?</p><ul><li>tail drop:丢失刚到达的分组</li><li>priority:根据优先权丢失/移除分组</li><li>random:随机的丢失/移除</li></ul><p>优先权：</p><p>按照分组的优先权选择发送下一个要通过链路传输的分组</p><h1 id="三、IP：Internet-Protocol"><a href="#三、IP：Internet-Protocol" class="headerlink" title="三、IP：Internet Protocol"></a>三、IP：Internet Protocol</h1><p>害，这里就放图了（你知不知道插图的过程虽然简单但是真的很烦耶）</p><h2 id="一-数据报格式"><a href="#一-数据报格式" class="headerlink" title="(一)数据报格式"></a>(一)数据报格式</h2><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013104324.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013104333.png"></p><h2 id="二-分片与重组"><a href="#二-分片与重组" class="headerlink" title="(二)分片与重组"></a>(二)分片与重组</h2><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013104345.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013104356.png"></p><h2 id="三-IPV4地址以及相关概念"><a href="#三-IPV4地址以及相关概念" class="headerlink" title="(三)IPV4地址以及相关概念"></a>(三)IPV4地址以及相关概念</h2><p>这一部分的话我觉得想学明白还是得多看看书，多查阅资料我就简单的放图了。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110219.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110234.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110247.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110302.png"></p><p>四种IP地址分类：</p><p><strong>A类IP地址</strong></p><p>A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是”0”；</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">地址的表示范围为：<span class="hljs-number">0.0.0.0</span>~<span class="hljs-number">127.255.255.255</span>；<br>默认子网掩码为：<span class="hljs-number">255.0.0.0</span> 或 /<span class="hljs-number">8</span>；<br><span class="hljs-number">255.0.0.0</span> =&gt;<span class="hljs-number">11111111</span>.<span class="hljs-number">00000000</span>.<span class="hljs-number">00000000</span>.<span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">网络号全为<span class="hljs-number">1</span>的IP:<span class="hljs-number">127</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>/<span class="hljs-number">8</span>表示保留，用于本机回环测试用。<br>主机号全为<span class="hljs-number">0</span>代表本主机所在的网络地址<span class="hljs-comment">;主机号全为1代表该网络上的所有主机.故不能分配。 </span><br><br>即：<br>A类地址可用的网络数为<span class="hljs-number">2</span>^<span class="hljs-number">7</span><span class="hljs-number">-2</span><span class="hljs-operator">=</span><span class="hljs-number">126</span>个；<br>每个网络能容纳的主机数为<span class="hljs-number">2</span>^<span class="hljs-number">24</span><span class="hljs-number">-2</span><span class="hljs-operator">=</span><span class="hljs-number">16777214</span>（上千万台）；<br>一般分配给规模比较大的网络使用。 <br></code></pre></td></tr></table></figure><p><strong>B类IP地址</strong></p><p>B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是”10”;</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">地址范围是<span class="hljs-number">128.0.0.0</span>到<span class="hljs-number">191.255.255.255</span>；<br>默认子网掩码为：<span class="hljs-number">255.255.0.0</span>或/<span class="hljs-number">16</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">主机号全为0代表本主机所在的网络地址;主机号全为1代表该网络上的所有主机.故不能分配。<br><br>即：<br> B类地址可用的网络数为2^<span class="hljs-attribute">14-1</span>=16383个；<br> 每个网络能容纳的主机数为2^<span class="hljs-attribute">16-2</span>=65534（上万台）；<br> 一般分配给中型的网络使用。<br></code></pre></td></tr></table></figure><p><strong>C类IP地址</strong></p><p>C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是”110”;</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">地址范围是<span class="hljs-number">192.0.0.0</span>到<span class="hljs-number">223.255.255.255</span>；<br>默认子网掩码为：<span class="hljs-number">255.255.255.0</span>或/<span class="hljs-number">24</span>；<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">主机号全为0代表本主机所在的网络地址;主机号全为1代表该网络上的所有主机.故不能分配。<br><br>即：<br> C类地址可用的网络数为2^<span class="hljs-attribute">21-1</span>=2097151个；<br> 个网络能容纳的主机数为2^<span class="hljs-attribute">8-2</span>=254台;<br> 一般分配给小型的网络使用。 <br></code></pre></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><table><thead><tr><th align="center"><strong>IP地址</strong></th><th align="center"><strong>说明</strong></th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">0.0.0.0</td><td align="center">表示整个网络</td><td align="center">可表示本机源地址，也可表示某个特定主机</td></tr><tr><td align="center">255.255.255.255</td><td align="center">一个特殊的广播地址，意味着所有的主机</td><td align="center">x.255.255.255/x.x.255.255/x.x.x.255</td></tr><tr><td align="center">127.x.x.x</td><td align="center">回环测试地址，默认127.0.0.1</td><td align="center">127.0.0.2 127.1.1.1都可以代表本机回环地址</td></tr></tbody></table><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110321.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110331.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110349.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110413.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110425.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013110440.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013111935.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013111946.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013111958.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013112008.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013112019.png"></p><h2 id="四-DHCP-Dynamic-Host-Configuration-Protocol"><a href="#四-DHCP-Dynamic-Host-Configuration-Protocol" class="headerlink" title="(四)DHCP:Dynamic Host Configuration Protocol"></a>(四)DHCP:Dynamic Host Configuration Protocol</h2><p>允许主机在加入网络的时候，动态地从服务器那里获得IP地址….这一块还得重新学习一下，有一个关于子网的问题。</p><h2 id="五-NAT-Network-Address-Translation"><a href="#五-NAT-Network-Address-Translation" class="headerlink" title="(五)NAT:Network Address Translation"></a>(五)NAT:Network Address Translation</h2><p>感觉不重要…</p><h2 id="六-IPV6"><a href="#六-IPV6" class="headerlink" title="(六)IPV6"></a>(六)IPV6</h2><p>为什么有IPV4还要IPV6？</p><p>因为IPV4用完了，并且IPV6对IPV4的不足做了优化。</p><p><strong>IPv6数据报格式</strong>：<strong>固定的40 字节头部，数据报传输过程中，不允许分片</strong></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013193821.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013193830.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221013193842.png"></p><h1 id="四、通用转发和SDN"><a href="#四、通用转发和SDN" class="headerlink" title="四、通用转发和SDN"></a>四、通用转发和SDN</h1><h2 id="一-网络层"><a href="#一-网络层" class="headerlink" title="(一)网络层"></a>(一)网络层</h2><p>网络层功能：</p><ul><li>转发：对于从某个端口到来的分组转发到合适的输出端口</li><li>路由：觉得分组从源端到目标端的路径</li><li>网络层包括数据平面和控制平面。</li></ul><p>路由器的网络层功能：</p><ul><li>IP转发：对于到来的分组按照路由表决定如何转发，数据平面</li><li>路由：决定路径，计算路由表；处在控制平面</li></ul><p>还有其他种类繁多网络设备（中间盒）：</p><ul><li>交换机；防火墙；NAT；IDS；负载均衡设备</li></ul><p>网络设备控制平面的实现方式特点：</p><p>互联网网络设备：传统方式都是通过分布式，每台设备的方法来实现数据平面和控制平面功能</p><ul><li>垂直集成：每台路由器或其他网络设备，包括<ul><li>硬件、在私有的操作系统</li><li>互联网标准协议（IP,RIP,IS-IS,OSPF,BGP)的私有实现</li><li>从上到下都有一个厂商提供*代价大，被设备上“绑架”）</li></ul></li><li>每个设备都实现了数据平面和控制平面的事情<ul><li>控制平面的功能是分布式实现的</li></ul></li><li>设备基本上只能（分布式升级困难）按照固定方式工作， 控制逻辑固化。不同的网络功能需要不同的</li><li>数据+控制平面）集成&gt;（控制逻辑）分布-&gt;固化<ul><li>代价大；升级困难；管理困难等</li></ul></li></ul><p>传统方式实现网络功能的问题</p><ul><li>垂直集成&gt;昂贵、不便于创新的生态</li><li>分布式、固化设备功能==网络设备种类繁多<ul><li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li><li>配置错误影响全网运行；升级和维护会涉及到全网设备：管理困难</li><li>要增加新的网络功能，需要设计、实现以及部署新的 特定设备，设备种类繁多</li></ul></li><li>~2005: 开始重新思考网络控制平面的处理方式<ul><li>集中：远程的控制器集中实现控制逻辑</li><li>远程：数据平面和控制平面的分离</li></ul></li></ul><h2 id="二-SDN"><a href="#二-SDN" class="headerlink" title="(二)SDN"></a>(二)SDN</h2><p><strong>SDN:逻辑上集中的控制平面</strong> 实现了控制平面和数据平面的分离。</p><p>一个不同的（通常是远程）控制器和CA交互，控制器决定分组 转发的逻辑（可编程），CA所在设备执行逻辑。</p><p>SDN的实现思路：</p><ul><li>网络设备数据平面和控制平面分离</li><li>数据平面-分组交换机<ul><li>将路由器、交换机和目前大多数网络设备的功能进一步抽象成：按照流表（由控制平面设置的控制逻辑）进行PDU （帧、分组）的动作（包括转发、丢弃、拷贝、泛洪、阻塞）</li><li>统一化设备功能：SDN交换机（分组交换机），执行控制逻辑</li></ul></li></ul><p>SDN控制平面和数据平面分离的优势</p><ul><li>水平集成控制平面的开放实现（而非私有实 现），创造出好的产业生态，促进发展<ul><li>分组交换机、控制器和各种控制逻辑网络应用app可由不同 厂商生产，专业化，引入竞争形成良好生态</li><li>集中式实现控制逻辑，网络管理容易<ul><li>集中式控制器了解网络状况，编程简单，传统方式困难</li><li>避免路由器的误配置</li></ul></li><li>基于流表的匹配+行动的工作方式允许“可编程的”分组交换机<ul><li>实现流量工程等高级特性</li><li>在此框架下实现各种新型（未来）的网络设备</li></ul></li></ul></li><li>流量工程：传统路由比较困难</li></ul><p>不想贴图了，呜呜，看书看书。</p><h2 id="三-OpenFlow"><a href="#三-OpenFlow" class="headerlink" title="(三)OpenFlow"></a>(三)OpenFlow</h2><p>OpenFlow数据平面抽象</p><ul><li>流:由分组（帧）头部字段所定义</li><li>通用转发：简单的分组处理规则<ul><li>模式: 将分组头部字段和流表进行匹配</li><li>行动：对于匹配上的分组，可以是丢弃、转发、修改、 将匹配的分组发送给控制器</li><li>优先权Priority: 几个模式匹配了，优先采用哪个，消除歧义</li><li>计数器Counters:#bytes 以及#packets</li><li>路由器中的流表定义了路由器的匹配+行动规则（流表由控制器计算并下发）</li></ul></li></ul><p>这个上课的时候其实我也没怎么弄明白，得查阅资料学习一下。</p><h1 id="五、中间设备（补充）"><a href="#五、中间设备（补充）" class="headerlink" title="五、中间设备（补充）"></a>五、中间设备（补充）</h1><p>从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备：</p><p>①物理层使用的中间设备叫 <strong>转发器</strong></p><p>②数据链路层使用的中间设备叫作<strong>网桥</strong>或<strong>桥接器</strong>，以及<strong>交换机</strong>。</p><p>③网络层使用的中间设备叫作<strong>路由器</strong></p><p>④在网络层以上使用的中间设备叫作<strong>网关</strong>。用网关连接两个不兼容的系统需要在高层进行协议的转换。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记-第三章-传输层</title>
    <link href="/2022/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2022/10/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221009171651.png"></p><p>[TOC]</p><h1 id="一、概述和传输层服务"><a href="#一、概述和传输层服务" class="headerlink" title="一、概述和传输层服务"></a>一、概述和传输层服务</h1><ul><li>传输服务与协议<ul><li>为运行在不同主机上的应用进程提供逻辑通信</li><li>传输协议运行在端系统<ul><li>发送方：将应用层的报文分成报文段，然后传递给网络层</li><li>接收方：将报文段重组成报文，然后传递给应 用层</li></ul></li></ul></li><li>传输层 VS 网络层<ul><li>网络层服务：主机之间的逻辑通信</li><li>传输层服务：进程间的逻辑通信<ul><li>依赖于网络层的服务：延时、带宽</li><li>并对网络层的服务进行增强：数据丢失、顺序混乱、加密</li><li>有些服务是可以加强的：不可靠 -&gt; 可靠；安全</li><li>但有些服务是不可以被加强的：带宽，延迟</li></ul></li></ul></li><li>Internet传输层协议<ul><li>可靠的、保序的传输：TCP<ul><li>多路复用、解复用</li><li>拥塞控制</li><li>流量控制</li><li>建立连接</li></ul></li><li>不可靠、不保序的传输：UDP<ul><li>多路复用、解复用</li><li>没有为尽力而为的IP服务添加更多的其它额外服务</li></ul></li><li>都不提供的服务<ul><li>延时保证</li><li>带宽保证</li></ul></li></ul></li></ul><h1 id="二、多路复用与解复用"><a href="#二、多路复用与解复用" class="headerlink" title="二、多路复用与解复用"></a>二、多路复用与解复用</h1><ul><li><p>多路复用/解复用</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221009201754.png"></li></ul></li><li><p>多路解复用工作原理</p><ul><li><p>UDP和TCP不同</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221009202809.png"></p></li></ul></li><li><p>无连接的多路解复用</p></li><li><p>面向连接（TCP）的多路复用</p><ul><li>TCP套接字：四元组本地标识<ul><li>源IP地址</li><li>源端口号</li><li>目标IP地址</li><li>目标端口号</li></ul></li><li>解复用：接收主机用这四个值来将数据报定位到合适的套接字</li><li>服务器能够在一个TCP端口上同时支持多个TCP套接字<ul><li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li></ul></li><li>Web服务器对每个连接客户端有不同的套接字<ul><li>非持久对每个请求有不同的套接字</li></ul></li></ul></li></ul><h1 id="三、无连接传输：UDP"><a href="#三、无连接传输：UDP" class="headerlink" title="三、无连接传输：UDP"></a>三、无连接传输：UDP</h1><ul><li>无连接传输：UDP<ul><li>UDP：User Datagram Protocol[RFC 768]</li><li>“no frills,” “bare bone”Internet 传输协议</li><li>“尽力而为”的服务，报文段可能：<ul><li>丢失</li><li>送到应用进程的报文段乱序</li></ul></li><li>无连接<ul><li>UDP发送端和接收端之间没有握手</li><li>每个UDP报文段都被独立地处理</li></ul></li><li>UDP被用于<ul><li>流媒体（丢失不敏感，速率敏感、应用可控制 传输速率）</li><li>DNS</li><li>SNMP</li></ul></li><li>在UDP上可行可靠传输<ul><li>在应用层增加可靠性</li><li>应用特定的差错恢复</li></ul></li></ul></li><li>UDP：用户数据报协议</li><li>UDP校验和<ul><li>目标：检测在被传输报文段中的差错(如比特反转)</li><li>发送方<ul><li>将报文段的内容视为16比特的整数</li><li>校验和：报文段的加法和(1的补运算）</li><li>发送方将校验和放在UDP的校验和字段</li></ul></li><li>接收方<ul><li>计算接收到的报文段的校验和</li><li>检查计算出的校验和与校验 和字段的内容是否相等</li><li>发送方将校验和放在UDP的校验和字段</li></ul></li></ul></li></ul><h1 id="四、可靠数据传输的原理"><a href="#四、可靠数据传输的原理" class="headerlink" title="四、可靠数据传输的原理"></a>四、可靠数据传输的原理</h1><p>这一块我感觉老师讲的很细，但我没怎么听明白…</p><p>这里面涉及的重点主要是可靠数据是怎么传输的，流水线协议（即允许发送方在未得到对方的确定的情况下，再下一次的发送分组时可以发送多个分组），滑动窗口，超时重传机制等等。</p><h1 id="五、面向连接的传输：TCP"><a href="#五、面向连接的传输：TCP" class="headerlink" title="五、面向连接的传输：TCP"></a>五、面向连接的传输：TCP</h1><ul><li>TCP概述<ul><li>点到点：一个发送方，一个接收方</li><li>可靠的、按顺序的<strong>字节流</strong>而且没有报文边界</li><li>管道化（流水线）<ul><li>TCP拥塞控制和流量控制设置窗口大小</li></ul></li><li>具有发送缓存和接收缓存</li><li>全双工通信<ul><li>在同一连接中数据流双向流动</li><li>MSS:最大报文段大小</li></ul></li><li>面向连接<ul><li>三次握手（四次挥手）</li></ul></li></ul></li><li>TCP报文段（这一块看书吧）</li><li>TCP往返延时（RTT）和超时<ul><li>Q:怎样设置TCP超时？<ul><li>比RTT要长<ul><li>但RTT是变化的</li></ul></li><li>太短：太早超时<ul><li>不必要的重传</li></ul></li><li>太长<ul><li>对报文段丢失反应太慢，消极</li></ul></li></ul></li><li>Q:怎样估计RTT？<ul><li>这里好像有计算公式 具体得看书</li></ul></li></ul></li><li>流量控制：接收方控制发送方，不让发送方发送的太多太快，以至于让接收方的缓冲区溢出<ul><li>流量控制和拥塞控制相似，切勿弄混。</li></ul></li><li>快速重传<ul><li>超时周期往往太长<ul><li>在重传丢失报文段之前的延时太长</li></ul></li><li>通过重复的ACK来检测报文段丢失<ul><li>发送方通常连续发送大量报文段</li><li>如果报文段丢失，通常会引起多个重复的ACK</li></ul></li><li>如果发送方收到同一数据的3个冗余ACK，重传最小序号的段<ul><li>快速重传：在定时器过时之前重发报文段</li><li>它假设跟在被确认的数据后面的数据丢失了<ul><li>第一个ACK是正常的,收到第二个该段的ACK，表示接收方收到一个该段后的乱序段；收到第3，4个该段的ack，表示接收方收到该段之后的2个，3个乱序段，可能性非常大段丢失了</li></ul></li></ul></li></ul></li></ul><h1 id="六、拥塞控制原理"><a href="#六、拥塞控制原理" class="headerlink" title="六、拥塞控制原理"></a>六、拥塞控制原理</h1><ul><li><p>拥塞</p><ul><li><p>可以把出现网络拥塞的条件写成下列的关系式</p><p><strong>对资源的所有需求 &gt; 可用资源</strong></p></li><li><p>拥塞表现</p><ul><li>分组丢失（路由器缓冲区溢出)</li><li>分组经历比较长的延迟（在路由器的队列中排队）</li></ul></li><li><p>这也是网络中top10的问题</p></li><li><p>相关拥塞例子（感觉不重要 先不记录了）</p></li></ul></li><li><p>拥塞控制方法</p><ul><li>端到端的拥塞控制<ul><li>没有来自网络的显式反馈</li><li>端系统根据延迟和丢失事件推断是否有拥塞</li><li>TCP采用的方法</li></ul></li><li>网络辅助的拥塞控制<ul><li>路由器提供给端系统以反馈信息<ul><li>单个bit置位，显示有拥塞 (SNA, DECbit, TCP/IP ECN, ATM)</li><li>显式提供发送端可以采用的速率</li></ul></li></ul></li></ul></li></ul><h1 id="七、TCP拥塞控制"><a href="#七、TCP拥塞控制" class="headerlink" title="七、TCP拥塞控制"></a>七、TCP拥塞控制</h1><ul><li><p>端到端的拥塞控制机制</p><ul><li>路由器不向主机有关拥塞的反馈信息<ul><li>路由器的负担较轻</li><li>符合网络核心的简单的TCP/IP架构原则</li></ul></li><li>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</li></ul></li><li><p>TCP拥塞控制：拥塞感知</p><ul><li><p>当某个时段超时了（丢失事件）：拥塞</p><ul><li>超时时间到，某个段的确认没有来</li><li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</li><li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li></ul></li><li><p>有关某个段的3次重复ACK：轻微拥塞</p><ul><li>段的第1个ack，正常，确认绿段，期待红段</li><li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</li><li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了 ，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了， 红段都没到）</li><li>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20221009212955.png"></p></li></ul></li><li><p>TCP拥塞控制策略</p><ul><li>慢启动</li><li>AIMD:线性增、乘性减少</li><li>超时事件后的保守策略</li></ul></li><li><p>TCP慢启动（只是启动蛮，但速度不慢）</p><ul><li>连接刚建立, CongWin = 1 MSS<ul><li>如: MSS = 1460bytes &amp; RTT = 200 msec</li><li>初始速率 = 58.4kbps</li></ul></li><li>可用带宽可能&gt;&gt; MSS/RTT<ul><li>应该尽快加速，到达希望的速率</li></ul></li><li>当连接开始时，指数性增 加发送速率，直到发生丢失的事件<ul><li>启动初值很低</li><li>但是速度很快</li></ul></li><li>当连接开始时，指数性增 加（每个RTT）发送速率 直到发生丢失事件<ul><li>每一个RTT， CongWin加倍</li><li>每收到一个ACK时， CongWin加1（why）</li><li>慢启动阶段：只要不超时或 3个重复ack，一个RTT，CongWin加倍</li></ul></li><li>总结: 初始速率很慢，但是加速却是指数性的<ul><li>指数增加，SS时间很短，长期来看可以忽略</li></ul></li></ul></li><li><p>TCP拥塞控制：AIMD</p><ul><li>乘性减<ul><li>丢失事件后将CongWin降为1， 将CongWin/2作为阈值，进入慢启动阶段（倍增直到 CongWin/2）</li></ul></li><li>加性增<ul><li>当CongWin&gt;阈值时，一个 RTT如没有发生丢失事件 ,将CongWin加1MSS: 探测</li></ul></li><li>当收到三个重复的ACKs<ul><li>CongWin 减半</li><li>窗口（缓冲区大小）之后 线性增长</li></ul></li><li>当超时事件发生时<ul><li>CongWin被设置成 1 MSS，进入SS阶段</li><li>之后窗口指数增长</li><li>增长到一个阈值（上次发 生拥塞的窗口的一半）时 ，再线性增加</li></ul></li><li>思路<ul><li>3个重复的ACK表示网络 还有一定的段传输能力</li><li>超时之前的3个重复的 ACK表示“警报”</li></ul></li></ul></li><li><p>感觉自己这一块没有完全的明白，还得再看看书。</p></li></ul><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>先看书再去看视频会掌握的更好。</p><p><a href="https://blog.csdn.net/qq_60387902?spm=1018.2226.3001.5343"><strong>我希望看见这句话的人永远开心</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记-第二章-应用层</title>
    <link href="/2022/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2022/09/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929153906.png"></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>⚡写了第一章的笔记以后发现如果所有的笔记都写的话工作量有点大，所以从第二章开始就只记录一些重点的以及不熟悉的知识点啦，并不会全部记录~好伐啦让我们一起进入计算机网络-第二章🔥    </p><h1 id="二、应用层协议原理"><a href="#二、应用层协议原理" class="headerlink" title="二、应用层协议原理"></a>二、应用层协议原理</h1><ul><li><p>网络应用的体系结构</p><ul><li>客户-服务器模式（C/S模式）<ul><li>服务器<ul><li>一直运行</li><li>固定的IP地址和周知的端口号（约定）</li><li>扩展性：服务器场–数据中心进行扩展且扩展性差</li></ul></li><li>客户端<ul><li>主动与服务器通信</li><li>与互联网有间接性的连接</li><li>可能是动态IP地址</li><li>不直接与其他客户端通信</li></ul></li></ul></li><li>对等体（P2P)体系结构<ul><li>（几乎）没有一直运行的服务器</li><li>任意端系统之间可以进行通信</li><li>每一个节点既是客户端又是服务器<ul><li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li></ul></li><li>参与的主机间歇性连接且可以改变IP地址</li><li>例子：迅雷</li></ul></li><li>C/S 和 P2P体系结构的混合体<ul><li>Napster<ul><li>文件搜索：集中<ul><li>主机在中心服务器上注册其资源</li><li>主机向中心服务器查询资源位置</li></ul></li><li>文件传输：P2P</li></ul></li><li>即时通信<ul><li>在线检测：集中<ul><li>当用户上线时，向中心服务器注册其IP地址</li><li>用户与中心服务器联系，以找到其在线好友的位置</li><li>两个用户的聊天：P2P</li></ul></li></ul></li></ul></li></ul></li><li><p>进程通信</p><ul><li>客户端进程：发起通信的进程</li><li>服务器进程：等待连接的进程<ul><li>在同一个主机中，使用<strong>进程通信机制</strong>通信</li><li>不同主机通过<strong>交换报文</strong>进行通信<ul><li>使用OS（操作系统）提供的通信服务</li><li>按照应用协议交换报文<ul><li>借助传输层提供的服务</li></ul></li></ul></li></ul></li><li>注意：P2P架构的应用也有客户端和服务器进程之分</li></ul></li><li><p>分布式进程通信需要解决的问题</p><ul><li>进程标识和寻址问题（<strong>服务用户</strong>）<ul><li>进程为了接收报文，必须有一个标识，即SAP（发送也需要标识）<ul><li>主机：唯一的32位IP地址<ul><li>仅仅用IP地址不能够唯一的标识一个进程，在一台端系统上有很多应用进程在运行</li></ul></li><li>采用的传输层协议：TCP or UDP</li><li>端口号（Port Numbers）<ul><li>下面是一些知名端口号例子<ul><li>HTTP：TCP 80</li><li>Mail:TCP 25</li><li>ftp:TCP 2</li></ul></li></ul></li><li>一个进程用IP+Port标识端节点</li><li>本质上，一对主机进程之间的通信由2个端节点构成</li></ul></li></ul></li></ul></li><li><p>传输层提供的服务-需要穿过层间的信息</p><ul><li>层间接口必须要携带的信息<ul><li>要传输的报文（对于本层来说：SDU）</li><li>谁传的：己方的应用进程的标示：IP+TCP(UDP)端口</li><li>传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口</li></ul></li><li>传输层实体（TCP或UDP实体）根据这些信息进行TCP报文段（UDP数据报）的封装<ul><li>源端口号，目标端口号，数据等</li><li>将IP地址往下交IP实体，用于封装IP和数据报：源IP和目标IP</li></ul></li></ul></li><li><p>传输层提供的服务-层间信息的代表</p><ul><li>如果Socket API每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理-&gt;使用套接字</li><li>用个代号标示通信的双方或者单方：socket</li><li>TCP socket这里先不说，后面会有详细的说明</li><li>UDP socket这里先不说，后面会有详细的说明</li></ul></li><li><p>应用层协议：定义了：运行在不同端系统上的应用进程如何相互交换报文</p><ul><li>交换的报文类型：请求和应答报文</li><li>各种报文类型的语法：报文中各个字段及其描述</li><li>字段的语义：字段取值的含义</li><li>进程何时、如何发送报文以及对报文进行响应的规则<ul><li>应用协议仅仅是应用的一个组成部分<ul><li>Web应用：HTTP协议、web客户端、web服务器、HTML</li></ul></li></ul></li></ul></li><li><p>应用层需要传输层提供什么样的服务？如何描述传输层的服务？</p><ul><li><p>数据丢失率</p><ul><li>有些应用要求100%的可靠数据传输，例如文件</li><li>有些应用，例如音频，能荣仍一定比例数据的丢失</li></ul></li><li><p>延迟</p><ul><li>延迟、延迟差，比如电话，打游戏的延迟</li></ul></li><li><p>吞吐</p><ul><li>一些应用，例如多媒体，必须需要最小限度的吞吐，从而使得应用能够有效的运转</li><li>一些应用能够充分利用可供使用的吞吐（弹性应用）</li></ul></li><li><p>安全性</p><ul><li><p>机密性</p></li><li><p>完整性</p></li><li><p>可鉴别性</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929151608.png"></p></li></ul></li></ul></li><li><p>TCP服务</p><ul><li>可靠的数据传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐保证和安全</li><li>面向连接：要求客户端进程和服务器进程之间建立连接</li></ul></li><li><p>UDP服务</p><ul><li>不可靠的数据传输服务</li><li>不提供的服务：可靠、流量控制、拥塞控制、时间、带宽保证、建立连接</li></ul></li><li><p>UDP<strong>存在的必要性</strong></p><ul><li>能够区分不同进程，而IP服务不能<ul><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li>无需建立连接</li><li>不做可靠的工作，例如检错重发</li><li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据<ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul></li><li><p>安全TCP</p><ul><li>TCP&amp;UDP<ul><li>都没有加密</li></ul></li><li>SSL<ul><li>在TCP上面实现，提供加密的TCP连接，具有私密性，数据完整性，端到端的鉴别</li><li>SSL在应用层，使用SSL库，而SSL库使用TCP通信</li><li>SSL socket API 应用将明文交给socket，SSL将其加密并在互联网上传输</li></ul></li></ul></li></ul><h1 id="三、Web-and-HTTP"><a href="#三、Web-and-HTTP" class="headerlink" title="三、Web and HTTP"></a>三、Web and HTTP</h1><ul><li><p>HTTP是<strong>无状态</strong>的</p><ul><li>服务器并不会维护关于客户的任何信息</li></ul></li><li><p>维护状态的协议很复杂</p><ul><li>必须维护历史信息状态</li><li>如果服务器/客户端死机，它们的状态信息可能不一致，二者的信息必须是一致</li><li>无状态的服务器能够支持更多的客户端</li></ul></li><li><p>HTTP连接</p><ul><li>非持久的HTTP<ul><li>最多只有一个对象在TCP连接上发送</li><li>下载多个对象需要多个TCP连接</li><li>HTTP/1.0 使用非持久性连接</li></ul></li><li>非持久的HTTP特点<ul><li>每个对象要2个RTT<ul><li><strong>RTT (Round Trip time):<em>从客户端发送一个很小的数据包到服务器并返回所经历的时间。</em></strong></li></ul></li><li>操作系统必须为每个TCP连接分配资源</li><li>但浏览器通常打开并行TCP连接，以获取引用对象</li></ul></li><li>持久HTTP<ul><li>多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输</li><li>HTTP/1.1 默认使用持久连接</li></ul></li><li>持久HTTP特点<ul><li>服务器在发送响应后，仍保持TCP连接</li><li>在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送</li><li>客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求</li></ul></li><li>非流水式的持久HTTP<ul><li>客户端只能在收到前一个响应后才能发出新的请求</li><li>每个引用对象花费一个RTT</li></ul></li><li>流水式的持久HTTP<ul><li>HTTP/1.1的默认模式</li><li>客户端遇到一个引用对象就立即产生一个请求</li><li>所有引用（小）对象只花费一个RTT是可能的</li></ul></li></ul></li><li><p>HTTP请求报文</p><ul><li>两种类型的HTTP报文：请求、响应</li><li>相关方法类型：GET、POST、HEAD、PUT、DELETE</li></ul></li><li><p>HTTP响应状态码</p><p>他们位于服务器-&gt;客户端的响应报文的首行</p><ul><li><p>200 OK 请求成功，请求对象包含在响应报文的后续部分</p></li><li><p>301 Moved Permanently  </p><p>请求的对象已经被永久转移了，新的URL在响应报文的Location,首部行中指定</p><p>客户端软件自动用新的URL去获取对象</p></li><li><p>400 Bad Request 一个通用的差错代码，表示该请求不能被服务器解读</p></li><li><p>404 Not Found 请求的文档在该服务上没有找到</p></li><li><p>505 HTTP Version Not Supported</p></li></ul></li><li><p>用户-服务器状态：cookies 大多数主要的门户网站使用cookies</p><ul><li>四个组成部分<ul><li>在HTTP响应报文中有一个cookies的首部行</li><li>在HTTP请求报文含有一个cookies的首部行</li><li>在用户端系统中保留有一个cookies文件，由用户的浏览器管理</li><li>在Web站点有一个后端数据库</li></ul></li><li>Cookies能带来什么<ul><li>用户验证</li><li>购物车</li><li>推荐</li><li>用户状态</li></ul></li><li>如何维护<ul><li>协议端节点：在多个事务上，发送端和接收端维持状态</li><li>cookies:http报文携带状态信息</li></ul></li><li>Cookies与隐私<ul><li>Cookies允许站点知道许多关于用户的信息、</li><li>可能将它知道的东西卖给第三方</li><li>使用重定向和cookies的搜索引擎还能知道用户更多的信息<ul><li>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</li></ul></li><li>广告公司从站点获得信息</li></ul></li></ul></li><li><p>Web缓存</p><p>目标：避免每次都访问服务器，减少服务器的工作需求</p><ul><li>在缓存中的对象：缓存直接返回对象</li><li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li><li>缓存既是客户端又是服务器</li><li>通常缓存是由ISP安装（大学、公司、居民区ISP）</li><li><strong>为什么要使用Web缓存？</strong><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li><li>互联网大量采用了缓存；可以使较弱的ICP也能够有效提供内容</li></ul></li><li>条件GET方法<ul><li>目标：如果缓存器中的对象拷贝是最新的，就不要发送对象</li><li>缓存器：在HTTP请求中指定缓存拷贝的日期</li><li>服务器：如果缓存拷贝陈旧，则响应报文没包含对象</li></ul></li></ul></li></ul><h1 id="四、FTP"><a href="#四、FTP" class="headerlink" title="四、FTP*"></a>四、FTP*</h1><p>感觉不是很重要，就贴图把！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929185627.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929185738.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929185832.png"></p><h1 id="五、Email"><a href="#五、Email" class="headerlink" title="五、Email"></a>五、Email</h1><p>老规矩，贴图~</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929190919.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929191019.png"><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929191116.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimage-20220929191201597.png"></p><h1 id="六、DNS"><a href="#六、DNS" class="headerlink" title="六、DNS"></a>六、DNS</h1><ul><li>DNS(Domain Name System -&gt; <strong>计算机域名</strong>)<ul><li>IP地址标识主机、路由器</li><li>IP地址不好记忆，存在着“字符串”向IP地址转换的重要性</li><li>人类用户提供要访问机器的“字符串”名称</li><li>有DNS负责转换成为二进制的网络地址</li></ul></li><li>DNS的历史<ul><li>APPANET的名字解析解决方案<ul><li>主机名：没有层次的一个字符串（一个平面）</li><li>存在着一个（集中）的维护站：维护着一张主机名-IP地址的映射文件：Hosts.txt</li><li>每台主机定时从维护站取文件</li></ul></li><li>APPANET解决方案的问题<ul><li>当网络中主机数量很大时<ul><li>没有层次的主机名称很难分配</li><li>文件的管理、发布、查找很麻烦</li></ul></li></ul></li></ul></li><li>DNS的总体思路和目标<ul><li>主要思路<ul><li>分层的、基于域的命名机制</li><li>若干分布式的数据库完成名字到IP地址的转换</li><li>运行到UDP之上端口号为53的应用服务</li><li>核心的Internet功能，但难以在应用层实现<ul><li>在网络边缘出来复杂性</li></ul></li></ul></li><li>主要目的<ul><li>实现主机名-IP地址的转换</li><li>其他目的<ul><li>主机别名到规范名字的转换：Host aliasing</li><li>邮件服务器别名到邮件服务器的正规名字的转换：Main server aliasing</li><li>负载均衡 load Distribution</li></ul></li></ul></li></ul></li><li>DNS系统需要存在的问题<ul><li>设备命名<ul><li>用有意义的字符串，方便记忆与使用</li><li>解决一个平面的重名问题：层次化命名</li></ul></li><li>名字到IP地址的转换<ul><li>分布式的数据库维护和响应名字查询</li></ul></li><li>如何维护增加或删除一个域，需要在域名工作中做什么</li></ul></li><li>DNS名字空间<ul><li>DNS域名结构<ul><li>一个层次命名设备会有很多重名</li><li>DNS采用层次树状结构的命名方法</li><li>Internet根被划为几百个顶级域（top lever domains)<ul><li>通用的<ul><li>.com;.edu;.gov;.int;.web</li></ul></li><li>国家的<ul><li>.cn;.us;.nl;.jp</li></ul></li></ul></li><li>每个（子）域下面可划分为若干子域</li><li>树叶是主机</li></ul></li><li>DNS名字空间<ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929193601.png"></li></ul></li><li>域名（Domain Name）<ul><li>从本域往上，直到树根</li><li>中间使用“.”间隔不同的级别</li><li>例如：xatu.edu.cn</li><li>域的域名：可以用来表示一个域</li><li>主机的域名：一个域上的主机</li></ul></li><li>域名的管理<ul><li>一个域管理其下的子域<ul><li>.jp被划分为ac.jp cp.jp</li><li>.cn被划分为edu.cn com.cn</li></ul></li><li>创建一个新的域必须要征得它所属域的同意</li></ul></li><li>域与物理网络无关<ul><li>域遵从组织界限，而不是物理网络<ul><li> 一个域的主机可以不在一个网络</li><li>一个网络的主机不一定在一个域</li></ul></li><li>域的划分是逻辑的，而不是物理的</li></ul></li></ul></li><li>解析名字-名字服务器（Name Server）<ul><li>一个名字服务器的问题<ul><li>可靠性问题：单点故障</li><li>扩展性问题：通信容量</li><li>维护问题：远距离的集中式数据库</li></ul></li><li>区域<ul><li>区域的划分由区域管理者自己决定</li><li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li><li>名字服务器<ul><li>每个区域都有一个名字服务器：维护着他所管辖区域的权威消息</li><li>名字服务器允许被放置在区域之外，以保障可靠性</li></ul></li></ul></li><li>名字空间划分为若干区域Zone<ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929194208.png"></li><li>权威DNS服务器：组织机构的DNS服务器，提供组织机构服务器可访问的主机和IP之间的映射，组织机构可以选择实现自己维护或某个服务提供商来维护</li></ul></li><li>顶级域（TLD）服务器：负责顶级域名（如com, org, net,  edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca,  jp ）<ul><li>Network solutions 公司维护comTLD服务器</li><li>Educause公司维护eduTLD服务器</li></ul></li><li>区域名字服务器维护资源记录<ul><li>资源记录<ul><li>作用：维护域名-IP地址(其他)的映射关系</li><li>位置：Name Server的分布式数据库中</li></ul></li><li>RR格式<ul><li>Domain_name:域名</li><li>Ttl:time to live:生存时间（权威，缓冲记录）</li><li>Class类别：对于Internet，值为IN</li><li>Value值：可以是数字，域名或ASCII串</li><li>Type类别<ul><li>Type=A:Name为主机，Value为IP地址</li><li>Type=CNAME:Name为规范名字的别名，Value为规范名字</li><li>Type=NS:Name为域名(如foo.com),Value为该域名的权威服务器的域名</li><li>Type=MX:Value为name对应的邮件服务器的名字</li></ul></li><li>TTL:生存时间-&gt;决定了资源记录应当从缓存中删除的时间</li></ul></li></ul></li></ul></li><li>DNS大致工作过程</li></ul><p>​    <img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/img20220929194955.png"></p><p>贴图贴图</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929195101.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929195158.png"></p><p>​    </p><p>这样做，一旦服务器学到了一个映射，就将该映射缓存起来。根服务器通常都在本地服务器中缓存着，使得根服务器不用经常被访问，可以达到提高效率的目的。可能会存在缓存结果和权威资源记录不一致。解决情况：TTL（默认聊天）</p><ul><li>新增一个域需要维护的问题<ul><li>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</li><li>在新增子域的名字服务器上运行名字服务器，负责本域的名字解析：名字–&gt;IP地址</li><li>例子：在com域中建立一个“Network Utopia”</li><li>到注册登记机构注册域名networkutopia.com<ul><li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</li><li>登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com, dns1.networkutopia.com, NS) (dns1.networkutopia.com, 212.212.212.1, A)</li></ul></li><li>在networkutopia.com的权威服务器中确保有<ul><li>用于Web服务器的<a href="http://www.networkuptopia.com的类型为a的记录/">www.networkuptopia.com的类型为A的记录</a></li><li>用于邮件服务器mail.networkutopia.com的类型为MX的记录</li></ul></li></ul></li></ul><h1 id="七、P2P应用"><a href="#七、P2P应用" class="headerlink" title="七、P2P应用"></a>七、P2P应用</h1><ul><li><p>纯P2P架构</p><ul><li>没有（或极少）一直运行的服务器</li><li>任意端系统都可以直接通信</li><li>利用peer的服务能力</li><li>Peer节点间歇上网，每次IP 地址都有可能变化</li><li>例子：<ul><li>文件分发（BitTorrent - &gt; 洪流)</li><li>流媒体（KanKan)</li><li>VoIP(Skype)</li></ul></li></ul><p>嗯这个应用这一块我自己有蛮多不理解的，就不记录了，到时候让自己百度加深印象和理解吧。</p></li></ul><h1 id="八、CDN"><a href="#八、CDN" class="headerlink" title="八、CDN"></a>八、CDN</h1><p>这一部分嗯贴贴图吧。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929204353.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929204422.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929204452.png"></p><h1 id="九、TCP套接字（Socket）编程"><a href="#九、TCP套接字（Socket）编程" class="headerlink" title="九、TCP套接字（Socket）编程"></a>九、TCP套接字（Socket）编程</h1><p>我们知道，TCP是可靠的、字节流的服务</p><ul><li>TCP socket：<ul><li>TCP服务，两个进程之间的通信之前需要建立连接<ul><li>两个进程的连接会持续一段时间，通信关系稳定</li></ul></li><li>可以用一个整数表示两个应用实体之间的通信关系，本地标识</li><li>穿过层间接口的信息量最小</li><li>TCP socket：源IP，源端口，目标IP，目标端口</li></ul></li><li>TCP套接字4元组是一个具有本地意义的标识<ul><li>4元组：源IP，源端口，目标IP，目标端口</li><li>唯一的指定了一个会话（2个进程之间的会话关系）</li><li>应用使用的这个标示，与远程的应用进程通信</li><li>不必在每一个报文的发送都要指定这4元组</li><li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li><li>简单，便于管理</li></ul></li><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929204951.png"></li></ul><p>​    <img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929205107.png"></p><h1 id="十、UDP套接字编程"><a href="#十、UDP套接字编程" class="headerlink" title="十、UDP套接字编程"></a>十、UDP套接字编程</h1><p>我们知道，UDP是不可靠的（数据UDP数据报）服务</p><ul><li><p>UDP socket</p><ul><li>UDP服务，两个进程之间的通信需要之前无需建立连接<ul><li>每个报文都是独立传输的</li><li>前后报文可能给不同的分布式进程</li></ul></li><li>因此，只能用一个整数表示本应用实体的标示<ul><li>因为这个报文可能传给另外一个分布式进程</li></ul></li><li>穿过层间接口的信息大小最小</li><li>UDP socket:本IP,本端口</li><li>但是传输报文时：必须要提供对方的IP，port<ul><li>接收报文时：传输层需要上传对方的IP，port</li></ul></li></ul></li><li><p>UDP 套接字</p><ul><li>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示<ul><li>2元组：IP，port(源端指定)</li><li>UDP套接字指定了应用所在的一个端节点（end point)</li><li>在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的ip和port</li><li>但是在发送报文时，必须要指定对方的ip和udpport</li></ul></li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929205750.png"></p></li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929205848.png"></p><h1 id="十一、碎碎念"><a href="#十一、碎碎念" class="headerlink" title="十一、碎碎念"></a>十一、碎碎念</h1><p><a href="https://blog.csdn.net/qq_60387902?spm=1000.2115.3001.5343"><strong>我希望看到这句话的人永远开心！</strong></a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络笔记-第一章-概述</title>
    <link href="/2022/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2022/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220929154156.png"></p><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>🍓前言内容对应的课程是p1和p2，很多同学看这一章的时候觉得很难，因为涉及了好多好多专有名词，可能会听着迷迷糊糊，我的建议是可以暂时听一遍，有一个大致的脉络就行。这两节课可以等你学完这门课程之后再回来温习一下，我相信你会醍醐灌顶的。好啦下面让我带你进入计算机网络的第一章吧！！！</p><h1 id="二、什么是Internet"><a href="#二、什么是Internet" class="headerlink" title="二、什么是Internet"></a>二、什么是Internet</h1><p>这个问题我们可以从两个方向来回答</p><p>🍉<strong>从具体构成角度</strong></p><ul><li><input disabled type="checkbox"> 节点<ul><li>主机及其上运行的应用程序（用方形表示）</li><li>路由器、交换机等网络交换设备（用圆形表示）</li><li>边：通信链路</li><li>接入网链路（access)：主机连接到互联网的链路，连接方形设备和圆形设备</li><li>主干链路（backbone）：路由器间的链路，连接圆形设备</li></ul></li><li><input disabled type="checkbox"> 协议<ul><li>端系统、分组交换机和其他因特网部件都要遵守一系列协议，这些协议控制因特网中信息的发送和接收</li><li>按层级不同，可以分为物理层协议，链路层协议，网络层协议，传输层协议和应用层协议，每一层的协议又可以分为若干种，如传输层协议有TCP,UDP；网络层协议有IP，一些路由选择协议。</li><li>因特网最为主要的两个协议是TCP（Transmission Control Protoclo，传输控制协议）和IP（Internet Protoclo，网络协议）</li><li>因特网的主要协议统称为TCP/IP，而计算机网络的主要协议不一定是TCP/IP，所以计算机网络是一个更大范围的概念</li></ul></li><li><input disabled type="checkbox"> 数以亿计的、互联的计算设备：<ul><li>主机即端系统，包括传统的桌面电脑，Linux工作站以及所谓的服务器，也包括我们的手机，平板、电视、一些穿戴设备等</li><li>运行网络应用程序</li></ul></li><li><input disabled type="checkbox"> 通信链路<ul><li>光纤、同轴电缆、无线、卫星</li><li>传输速率 = 带宽（bps）是以比特/秒（bit/s，或bps）来度量的</li></ul></li><li><input disabled type="checkbox"> 分组交换设备：转发分组（packets）<ul><li>路由器和交换机 二者区别：前者通常用于网络核心中，后者通常用于接入网中</li></ul></li><li><input disabled type="checkbox"> 路径<ul><li>从发送端系统到接收端系统，一个分组所经历的一系列通信链路和分组交换机称为通过该网络的路径</li></ul></li></ul><p>🍉<strong>从服务角度</strong></p><ul><li><input disabled type="checkbox"> 使用通信设施进行通信的分布式应用：<ul><li>将发送和接受数据的apps与互联网连接起来</li><li>为app应用提供服务选择，类似与邮政服务：无连接不可靠服务，面向连接的可靠服务</li></ul></li></ul><h1 id="三、网络边缘"><a href="#三、网络边缘" class="headerlink" title="三、网络边缘"></a>三、网络边缘</h1><p>🍑我们知道，网络结构分为网络边缘（edge），网络核心（core）和接入网(access）</p><p>网络边缘</p><ul><li>主机、端系统：与因特网相连的计算机和其他设备，它们都位于因特网的边缘，所以被称为端系统。端系统也称为主机（host），因为它们容纳（即运行）应用程序。主机可以进一步划分为两类：客户端（client）和服务器（server）。客户端是发起请求的一方，服务器是接收请求的一方。大部分提供搜索结果、电子邮件、Web 页面和视频的服务器都属于大型数据中心（data center）</li><li>应用进程通信的模式：客户/服务器模式（主从模式）和对等（peer-peer）模式<ul><li>客户端/服务器模式的缺点：可扩展性差</li><li>对等模式：很少（甚至没有）专门的服务器，可扩展性好，如分布式文件分发应用程序迅雷。每一个应用程序既可以作为客户端，也可以作为服务端</li></ul></li></ul><p>网络边缘：采用网络设施的面向连接服务</p><ul><li>在数据传输之前两个主机先要握手，建立连接（准备好相应的资源（缓存区，重置控制变量，设置超时定时器），做好标记）。TCP 在 Internet 上提供面向连接的服务，特点是可靠（不出错，不丢失，不重复，不冗余，也叫 RDT Reliable Data Transfer）、有序、有流量控制和拥塞控制。使用 TCP 的应用：Http应用、FTP（文件传输）</li></ul><p>网络边缘：采用基础设施的无连接服务</p><ul><li><p>UDP 在 Internet 上提供无连接的服务，特点是不可靠，没有流量控制和拥塞控制。使用 UDP 的应用：流媒体应用、远程会议</p><p>注意：面向连接和有连接是不同的：面向连接，通信的状态只是在端系统中维护，而不在数据交换节点中维护；有连接，通信的状态不仅要在端系统中维护，也要在数据交换节点中维护</p></li></ul><h1 id="四、网络核心"><a href="#四、网络核心" class="headerlink" title="四、网络核心"></a>四、网络核心</h1><p>🍍网络核心是由分组交换机和链路构成的网状网络，主要作用是数据交换</p><p>通过网络链路和交换机移动数据的有两种基本方法：电路交换(circuit switching)和分组交换(packet switching)</p><ul><li><p>电路交换</p><ul><li>在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存、链路传输速率）</li><li>在发送方发送信息之前，电路交换方式必须在发送方和接收方之间建立一条连接，被称为电路；同时，建立这条电路，需要消耗一定的时间</li><li>沿着发送方和接收方之间路径上的交换机都将为建立的连接维护连接状态，这导致了电路交换方式可靠性不高的问题（因为只要有一个交换机出问题了，连接就被打破了）</li><li>在连接期间，电路在该网络链路上预留了恒定的传输速率，这保证了通信的性能</li><li>给这条电路分配的资源是这条电路独享的资源，这样如果这条电路上没有数据发送，这些资源就会被浪费</li><li>电路一般不会占用全部的链路，如果把一条链路（1Mbps）分配给一条电路（100Kbps），这是一种浪费。所以，要将链路分成片，分片方式有：频分复用（Frequency-Division Mutliplexing，FDM），时分复用（Time-Division Mutliplexing，TDM），波分复用（Wave-Division Mutliplexing，WDM）</li></ul></li><li><p>分组交换</p><p>在端系统间通信会话期间，不会预留端系统间沿路径通信所需要的资源（缓存、链路传输速率）</p><p>链路带宽资源不再分片，而是把全部带宽都用于通信</p><p>多数分组交换机在链路的输入端使用<strong>存储转发传输</strong>（store-and-forward transmission）机制。存储转发传输机制是指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组</p><p>存储转发传输机制会带来存储转发时延</p><p>分组交换机具有一个输出缓存（output buffer，也称为输出队列（output queue）），用于存储转发到某条链路的分组。如果到达的分组需要到某条链路，但是该链路正在传输其他分组，那么这个到达的分组就必须在输出缓存中等待，这就带来了排队时延</p><p>当一个分组已到达需要排队，但是输出缓存已满，这时就会出现分组丢失（丢包）（packet loss）</p><p>路由器决定分组转发到哪条链路的原理：分组的首部包含了目的地的IP地址。每台路由器都有一个转发表（forwarding table），用于将目的地址（或目的地址的一部分）映射成输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索它的转发表，找到对应的输出链路。路由器将分组导向查到的那条输出链路</p><p>分组交换是时分复用使用链路资源，但是没有固定的划分模式，所以称为统计多路复用</p><p>分组交换网络按照有无网络层的连接，分成：数据报（datagram）网络和虚电路（virtual circuit）网络</p><p>下面是分组交换和电路交换的对比图以及内容</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923125612.png"></p></li></ul><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130110.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130218.png"></p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923130323.png"></p><p><strong>分组交换是重点！！！</strong></p><p>这里来一个数据报和虚电路的对比：</p><p><strong>TCP–虚电路</strong></p><p><strong>UDP–数据报</strong></p><table><thead><tr><th>对比的方面</th><th>虚电路</th><th>数据报</th></tr></thead><tbody><tr><td><strong>连接的建立</strong></td><td>必须有</td><td>不要</td></tr><tr><td><strong>目的站地址</strong></td><td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td>每个分组都有目的站的全地址</td></tr><tr><td><strong>路由选择</strong></td><td>在虚电路连接建立时进行，所有分组均按同一路由</td><td>每个分组独立选择路由</td></tr><tr><td><strong>当路由器出故障</strong></td><td>所有通过了出故障的路由器的虚电路均不能工作</td><td>出故障的路由器可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td><strong>分组的顺序</strong></td><td>总是按发送顺序到达目的站</td><td>到达目的站时可能不按发送顺序</td></tr><tr><td>端到端的差错处理</td><td>由通信子网负责，也可以由用户主机负责</td><td>由主机负责</td></tr><tr><td>端到端的流量控制</td><td>由通信子网负责，也可以由用户主机负责</td><td>由主机负责</td></tr></tbody></table><h1 id="五、接入网和物理媒介"><a href="#五、接入网和物理媒介" class="headerlink" title="五、接入网和物理媒介"></a>五、接入网和物理媒介</h1><p>🍐</p><ul><li><p>接入网</p><ul><li>接入网是指将端系统物理连接到其边缘路由器（edge router）的网络</li><li>边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</li></ul></li><li><p>接入环境</p><ul><li><p>住宅接入</p><p><strong>数字用户线（digital subscriber line，DSL）</strong></p><p>采用现有的住宅到电话公司的电话线（即双绞铜线）来传输数据；实际上是住宅的DSL调制解调器（俗称为“猫”）使用现有的电话线与位于电话公司的本地中心局（center office，CO）中的数字用户线接入复用器（DSLAM）交换数据；电话线同时承载了数据和传统的电话信号。DSLAM 把数据和电话信号分隔开，将数据送往因特网。“猫”将数据调制为高频模拟信号在电话线上传输，将来自电话线的高频模拟信号解调为数据供用户主机使用。</p><p>调频方式用不同的频率进行编码： •高速下行信道，位于50kHz到1 MHz频段； •中速上行信道，位于4kHz到50kHz频段； •普通的双向电话信道，位于0到4kHz频段</p><p><strong>线缆网络</strong></p><p>采用现有的住宅到有线电视信号线缆（即同轴电缆）来传输数据；需要把有线电视信号线缆双向改造（原有的是只能下行的）；在这个系统中应用了光纤和同轴电缆，所以它经常被称为混合光纤同轴（Hybrid Fiber Coax, HFC）系统；电缆因特网需要电缆调制解调器（cable modem）；在电缆头端，电缆调制解调器端接系统（Cable Modem Termination System, CMTS）将模拟信号转换回数字形式，发往互联网。</p><p>电缆因特网接入的一个重要特征是共享广播媒体。</p><p>家里的无线路由器其实是包含路由器，交换机（实现局部交换），调制解调器，防火墙，无限接入点的集合</p><p><strong>光纤到户</strong></p><p>Fiber To The Home, FTTH，有潜力提供每秒千兆比特范围的因特网接入速率</p><p>企业、单位接入：使用局域网（LAN）将端系统连接到边缘路由器。以太网用户使用双绞铜线与一台以太网交换机相连。以太网交换机或者这样相连的交换机再与更大的互联网相连；使用以太网接入，用户通常以100Mbps或 lGbps速率接入以太网交换机，而服务器可能具有lGbps甚至10Gbps的接入速率</p><p>无线接入：无线LAN：Wifi，距离短；广域无线接入：基站，距离长</p></li></ul></li><li><p>物理媒介</p><ul><li>导引型媒体：同轴电缆，光纤，双绞线</li><li>非导引型媒体：地面微波，LAN，wide-area，卫星</li></ul></li></ul><h1 id="六、Internet结构和ISP"><a href="#六、Internet结构和ISP" class="headerlink" title="六、Internet结构和ISP"></a>六、Internet结构和ISP</h1><p>🍇</p><p>ISP 有很多：住宅的 ISP，学校的 ISP，机构的 ISP</p><p>ISP 之间必须是互联的，这样才能保证不同的端系统可以互相访问    </p><p>多个全局 ISP 把接入 ISP 连接在一起，全局 ISP 之间通过 IXP（Internet exchange point） 连接在一起</p><p>区域 ISP 接入一定区域的端系统通过 POP（Point of presence）接入，全局 ISP 通过 IXP 连接区域 ISP</p><p>ICP（Internet Content Provider），互联网内容提供商，如百度，微信，会构建专用的网络，为用户提供更好的服务。ICP 也会和 ISP 互联</p><p>POP：高层 ISP 面向客户网络的接入点，涉及费用结算</p><p>IXP：多个对等 ISP 互联互通之处，通常不涉及费用结算</p><h1 id="七、分组延时、丢失和吞吐量"><a href="#七、分组延时、丢失和吞吐量" class="headerlink" title="七、分组延时、丢失和吞吐量"></a>七、分组延时、丢失和吞吐量</h1><ul><li><p>分组丢失的原因</p><ul><li>链路的队列缓冲区容量有限</li><li>当分组到达一个满的队列时，该分组会丢失</li><li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li></ul></li><li><p>分组延时</p><ul><li>节点处理延时<ul><li>检查bit级差错</li><li>检查分组首部和决定将分组导向何处</li></ul></li><li>排队延时<ul><li>在输出链路上等待传输的时间</li><li>依赖于路由器的拥塞程度</li></ul></li><li>传输延时<ul><li>R = 链路带宽（bps)</li><li>L= 分组长度(bits)</li><li>将分组发送到链路上的时间 = L/R</li><li>存储转发延时</li></ul></li><li>传播延时<ul><li>d = 物理链路的长度</li><li>s = 在媒体上的传播速度（2e8 m/sec)</li><li>传播延时 = d/s</li></ul></li></ul></li><li><p>节点延时</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923133412.png"></p></li><li><p>吞吐量</p><ul><li><p>吞吐量的含义：在源端和目标端之间传输的效率（数据量/单位时间）</p><ul><li><p>瞬时吞吐量：在一个时间点的速率</p></li><li><p>平均吞吐量：在一个长时间内平均值</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923133901.png"></p></li></ul></li></ul></li><li><p>流量强度用于估计排队延时</p><ul><li>a 表示分组到达队列的平均速率（a 的单位是分组/秒，即pkt/s）</li><li>R 表示链路传输速率，即主机或路由器向链路发送数据的速率，从队列中推出比特的速率，单位：bps，即 b/s</li><li>L 表示分组长度（假定所有分组都是 L 比特组成的），单位是比特</li><li>假定该队列无限大，比率 La / R 被称为流量强度。L/R 表示从队列中推出一个分组的速率，单位是s/pkt，而 a 表示分组到达队列的速率，La/R &gt; 1，则表示分组到达队列的平均速率超过从该队列传输岀去的速率，这样会导致队列无限增加，排队延时也将无限增加。因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1</li></ul></li></ul><h1 id="八、协议层次和服务模型"><a href="#八、协议层次和服务模型" class="headerlink" title="八、协议层次和服务模型"></a>八、协议层次和服务模型</h1><ul><li><p>因特网的复杂性</p><ul><li>因特网有大量的应用程序和协议、各种类型的端系统、分组交换机以及各种类型的链路级媒体。因此，必须组织网络体系结构</li></ul></li><li><p>分层的网络体系结构</p><ul><li>模块化：把复杂的功能分成子功能，每个模块完成一个特定的子功能，各模块组合起来成为整体，完成整个系统所要求的功能，而分层是特殊的模块化，只有上下层模块之间才可以相互沟通，不允许跨层调用</li><li>将网络复杂的功能分成功能明确的层次，每一层实现其中一个或一组功能，提供给上层使用的那些功能被称为服务</li><li>本层协议实体相互交互执行本层的协议动作，目的是实现本层功能，通过接口为上层提供更好的服务；在实现本层协议的时候，直接利用了下层提供的所有服务：本层要和对等层通信，需要使用下层提供的服务来实现</li><li>本层的服务：借助于下层提供的服务实现新的功能，也包括下层提供的服务</li><li>改变服务的实现不会影响该系统其他组件，这是因为该层对上面提供相同的服务（相同的层间接口），并且使用来自下面层次的相同服务，当这一层的实现变化时，该系统的其他部分保持不变</li><li>分层的缺点：效率低一些</li></ul></li><li><p>服务和服务访问点</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134801.png"></li></ul></li><li><p>服务的类型</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134845.png"></li><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimage-20220923134918106.png"></li></ul></li><li><p>数据单元（DU）</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923134950.png"><ul><li>SDU：service data unit 服务数据单元，上层交给下层传输的数据</li><li>ICI：interface control information 接口控制信息</li><li>IDU （interface data unit）= ICI + SDU</li><li>PDU：protocol data unit 协议数据单元，包括上层叫下来的数据和本层的头部信息</li></ul></li></ul></li><li><p>Internet协议栈</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135105.png"></li></ul></li><li><p>ISO/OSI参考模型</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135138.png"></li></ul></li><li><p>各层次的协议数据单元</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135214.png"></li></ul></li><li><p>封装与解封装</p><ul><li><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220923135256.png"></li></ul></li></ul><h1 id="九、计算机网络和因特网的历史"><a href="#九、计算机网络和因特网的历史" class="headerlink" title="九、计算机网络和因特网的历史"></a>九、计算机网络和因特网的历史</h1><ul><li><p>1960以前，线路交换网络的时代</p></li><li><p>1961~1964，分组交换理论建立</p></li><li><p>1961~1972，分组交换实验网络 ARPAnet（是互联网的前身）</p></li><li><p>1972~1980，专用网络和网络互联</p></li><li><p>1974: 网际互联的Cerf and Kahn 体系结构</p></li><li><p>1980~1990，体系结构变化, 网络数量激增，应用丰富</p></li><li><p>1983 TCP/IP 部署，标记日</p></li><li><p>1990, 2000’s，商业化, Web, 新的应用</p></li><li><p>1990年初 Web 出现</p></li><li><p>2005~现在</p></li><li><p>移动互联网的时代</p></li><li><p>物联网的时代</p></li></ul><p><strong>最后</strong></p><p>终于总结完了，开心开心，忘记说了文章内容是学习中科大的计算机网络然后这里看一下那里看一下总结的笔记！</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SunnyWeather</title>
    <link href="/2022/09/13/SunnyWeather/"/>
    <url>/2022/09/13/SunnyWeather/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>前言</strong>：好久没有管理自己的博客了，最近心血来潮回来捯饬了一下自己的博客感觉还是很不错的，一开始嫌麻烦觉得在这里写文章很麻烦，但是自己真正用心来弄的时候会发现这个东西并不难。确实，很多时候我们在做什么之前都会去考虑所做之事自己是否能够完成或轻松的完成，而我在很多时候遇到一些比较复杂的事情或者难题的时候，都会有一种畏难心理，导致自己心理上去抵制它哈哈哈，属实是不够成熟。好伐啦，我们准备进入正题之前，我想大致分享一下本篇博客的创作源泉以及创作目的。最近在学习Kotlin的天气，发现自己暑假看书得来的知识没有掌握好，并且对很多Kotlin的知识都不够熟悉不够了解，甚至一些基本用法自己都还不会，然后不得不花费很多时间去改bug（抄书都抄错┭┮﹏┭┮），害，不过还是成功的解决了问题，也在bug中加深了自己对一些知识的理解，就还挺不错的哈哈哈。昨天已经写（写（×）抄（√））完天气了，虽然完成的比较草率(?)哈哈哈，不过也是在低下的效率中逐渐掌握了一些新的知识，故写这篇博客来记录一下自己的学习记录！好啦让我们一起开启SunnyWeather的知识之旅☞！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimgwallhaven-z8l37o.jpg"></p><h1 id="一、功能需求及技术可行性分析"><a href="#一、功能需求及技术可行性分析" class="headerlink" title="一、功能需求及技术可行性分析"></a>一、功能需求及技术可行性分析</h1><p>⭐我们在做一个项目之前，首先应该对程序进行需求分析，想一想我们的项目里面需要有什么，需要实现什么功能…我们才动手去实现这些功能。目前SunnyWeather中需要具备一下功能：</p><p>🌼可以搜索全球大多数国家的各个城市数据</p><p>🌼可以查看全球绝大多数城市的天气信息（准确程度取决于你所使用的天气API）</p><p>🌼可以自由切换城市，查看其他城市的数据</p><p>🌼可以手动刷新天气</p><p>以上是该项目主要的功能点，如果需要全部实现这些功能需要用到网络、数据存储、协程、线程等等技术，还是有一定的难度的，但是既然你发现这这篇宝藏博客，那么我将手把手教会你👊！</p><p>⭐上面只说了项目的主要功能以及需要实现的相关技术，却没有涉及一个关键的点，那就是天气的信息该怎么获取，这个不用担心，已经有大佬为你做好了，你只需要会调用就行了。</p><p>本篇博客以彩云天气为例，简单介绍如何获得彩云天气的API。</p><p>🍃首先登录<a href="https://dashboard.caiyunapp.com/">彩云天气</a>官网注册：<a href="https://dashboard.caiyunapp.com/">https://dashboard.caiyunapp.com/</a></p><p>🍃注册完了以后，申请令牌（<strong>重要</strong>），这里还需要让你填写应用链接，由于还没有创建，可以先不填。</p><p>🍃拿到令牌以后就可以使用彩云天气提供的各种API接口了。</p><h1 id="二、Git代码托管"><a href="#二、Git代码托管" class="headerlink" title="二、Git代码托管"></a>二、Git代码托管</h1><p>⭐这里就对Git就不介绍了，毕竟你都能看见我的博客，那你肯定也略知一二，我自己其实也不够了解没什么发言权。好了进入正题，首先你需要有一个Git账号，然后新建一个仓库（Repository），不需要勾选其他的东西，默认就行了，然后点击Create repository按钮就创建成功了。</p><p>🍌接下来就需要创建项目了，在Android studio中新建一个Kotlin项目，创建完需要去将仓库的远程版本库克隆到本地，将仓库的版本库中的Https复制一份，然后打卡cmd，进入你这个项目的目录下，输入git clone （这里是你项目仓库的Https），克隆成功需要做一件事情，那就是将SunnyWeather项目中的文件都复制到上一层目录，这样做的目的：可以将整个项目工程目录添加到版本控制中去，这里有个坑，在这些文件里面有一个隐藏文件（.git），需要你文件夹设置一下才能看见这些隐藏的文件，把所有的文件复制到上一层的时候会有一个文件.gitignote文件，直接覆盖就好，复制完将SunnyWeather文件夹删除。哈哈可能你会觉得有点麻烦，没办法，我一开始接触的时候也觉得麻烦，因为对计算机这些指令不熟悉很陌生，不过没关系，以后就会习惯了。最后，将SunnyWeather项目中的文件提交到Github上面。</p><p>具体指令如下(接着上面的操作继续)：</p><p>🍍git add .         添加操作</p><p>🍍git commit -m “（这里可以描述你这次提交代码的简单说明，比如：First commit）”</p><p>🍍git push origin main</p><p>👁到这一步完成就成功的实现了Git代码托管。</p><h1 id="三、搭建MVVM项目框架"><a href="#三、搭建MVVM项目框架" class="headerlink" title="三、搭建MVVM项目框架"></a>三、搭建MVVM项目框架</h1><p>⭐由于这是我第一次搭建MVVM项目框架加上自己本身对MVVM也不够了解，我就不展开介绍了，详细可以看这个<a href="https://blog.csdn.net/lmq121210/article/details/80872652?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166306818616782391895448%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166306818616782391895448&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-7-80872652-null-null.142%5Ev47%5Epc_rank_34_1,201%5Ev3%5Econtrol&utm_term=%E5%AE%89%E5%8D%93mvvm%E6%A1%86%E6%9E%B6&spm=1018.2226.3001.4187">大佬的文章</a>，我们的项目需要严格按照MVVM项目框架进行搭建。在你的项目的包下新建几个包，项目结构如下图所示。</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913192832.png"></p><p>图中的logic包用于存放业务逻辑相关的代码，ui包用于存放页面展示相关的代码，而logic包下的dao、mode、network分别用于存放数据访问对象、对象模型以及网络相关的代码，ui包下的place和weather则是SunnyWeather中的两个主要界面。由于这些操作会涉及网络和对象存储等操作，需要导包，编辑app/build.gradle文件，如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913193511.png"></p><h1 id="四、搜索全球城市数据"><a href="#四、搜索全球城市数据" class="headerlink" title="四、搜索全球城市数据"></a>四、搜索全球城市数据</h1><p>⭐在开始写代码之前，我们可以先准备一些方便后期编程的一些工具类，这里需要写一样获得全局Context的工具类，并且将令牌配置在这里面。在你的项目的包下，新建一个SunnyWeatherApplycation类，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194107.png"></p><p>红色箭头所指填你申请到的令牌~</p><p>然后我们还需要在AndroidManifest.xml文件中更改android：name指定的内容，改为.SunnyWeatherApplication。</p><p>根据彩云天气的API文档，接下来我们开始定义相关的数据模型。</p><p>⭐在logic/model包下新建PlaceResponse.kt文件,并在这个文件中编写如下代码：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194417.png"></p><p>⭐接着定义彩云天气测试搜索API的Retrofit接口，在logic/network包下新建PlaceService接口，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194620.png"></p><p>⭐定义好了PlaceSertvice接口，我们需要使用它的前提得需要有一个Retrofir构建器，在logic/network包下新建一个ServiceCreator单例类，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913194907.png"></p><p>⭐然后我们需要再定义一个统一的网络数据源访问入口，对所有散落请求的API进行封装。同样在logic/network包下新建一个SunnyWeatherNetwork单例类，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195230.png"></p><p>⭐另外我们需要在logic包下新建一个Repository单例类，这是仓库层的统一封装入口，代码如下图所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195543.png"></p><p>⭐到这里，逻辑层的实现就只剩最后一步了，定义ViewModel层，这里对ViewModel层解释一下，它相当于逻辑层和UI层的一个桥梁，虽然它更偏向于逻辑层。在ui/place包下新建一个PlaceViewModel，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913195904.png"></p><p>🍉由于作者很懒，就不进行详细讲解了，天气的UI层代码以及RecyclerView的适配器和展示天气的PlaceFragment可以去我仓库clone查看，我就不在码字了，我的<a href="https://github.com/Crwei996/SunnyWeather">Github</a>，仓库名字即SunnyWeather。</p><p>注意：由于PlaceFragment中实现了一个搜索框布局，需要修改原生的ActionBar，修改res/values/theme.xml中的代码</p><p>改成这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;style name=<span class="hljs-string">&quot;Theme.SunnyWeather&quot;</span> parent=<span class="hljs-string">&quot;Theme.MaterialComponents.Light.NoActionBar&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>最后别忘记添加网络权限，AndroidManifest.xml文件中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;uses-permission android:name=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>完成这些就可以实现全球城市的搜索了，可以看我的Demo，这里不多放图了。</p><p>好了，关于城市搜索这块的代码就先写到这，现在提交代码到Github中去。</p><p>🍃git add .         添加操作</p><p>🍃git commit -m “（这里可以描述你这次提交代码的简单说明，比如：实现搜索全球城市数据功能）”</p><p>🍃git push origin main </p><h1 id="五、显示天气信息"><a href="#五、显示天气信息" class="headerlink" title="五、显示天气信息"></a>五、显示天气信息</h1><p>这一部分的逻辑和实现全球城市的搜索类似，根据API天气信息接口返回的JSON数据进行解析，具体操作如下：</p><p>⭐首先建立数据模型，在logic/model包下新建DailyResponse.kt文件，代码如下：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913202821.png"></p><p>🥥接着定义一个用于访问天气API的Retrofit接口，在logic/network包下新建WeatherService接口，代码如下：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203128.png"></p><p>⚡在SunnyWeatherNetwork这个网络数据源访问入口对新增的WeatherService接口进行封装，添加如下代码到SunnyWeatherNetwork：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203431.png"></p><p>💧完成了网络层的代码编写，和之前一样，创建仓库层，不过前面已经创建仓库层Repository了，在Repository中添加如下代码：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203625.png"></p><p>🍇到这逻辑层就只剩最后一步了，定义ViewModel层，在ui/weather包下新建一个WeatherViewModel，代码如下所示：</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913203856.png"></p><p>⚽又到了我要偷懒的UI层了，和上面的ui层一样去我仓库clone项目自己去看把，我手敲的好累。</p><p>📕天气的页面布局完成以后，我们还需要一个转换函数，将获得到的天气代码转成一个Sky对象，为什么要这样，因为返回的数据是这样的…哈哈哈哈，在logic/model包下新建一个Sky.kt文件，代码如下所示：（这里太长了就不截图了，截图截不全）</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs tp">class Sky(val info:String,val icon:Int,val bg:Int)<br>private val sky = mapOf(<br>    <span class="hljs-string">&quot;CLEAR_DAY&quot;</span> to Sky(<span class="hljs-string">&quot;晴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;CLEAR_NIGHT&quot;</span> to Sky(<span class="hljs-string">&quot;晴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;PARTLY_CLOUDY_DAY&quot;</span> to Sky(<span class="hljs-string">&quot;多云&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;PARTLY_CLOUDY_NIGHT&quot;</span> to Sky(<span class="hljs-string">&quot;多云&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;CLOUDY&quot;</span> to Sky(<span class="hljs-string">&quot;阴&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;WINDY&quot;</span> to Sky(<span class="hljs-string">&quot;大风&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;LIGHT_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;小雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;MODERATE_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;中雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br><br>    <span class="hljs-string">&quot;HEAVY_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;大雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;STORM_RAIN&quot;</span> to Sky(<span class="hljs-string">&quot;暴雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;THUNDER_SHOWER&quot;</span> to Sky(<span class="hljs-string">&quot;雷阵雨&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;SLEET&quot;</span> to Sky(<span class="hljs-string">&quot;雨夹雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;LIGHT_SHOW&quot;</span> to Sky(<span class="hljs-string">&quot;小雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;MODERATE_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;中雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HEAVY_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;大雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;STORM_SNOW&quot;</span> to Sky(<span class="hljs-string">&quot;暴雪&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HAIL&quot;</span> to Sky(<span class="hljs-string">&quot;冰雹&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;LIGHT_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;轻度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background, <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;MODERATE_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;重度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;HEAVY_HAZE&quot;</span> to Sky(<span class="hljs-string">&quot;重度雾霾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;FOG&quot;</span> to Sky(<span class="hljs-string">&quot;雾&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img),<br>    <span class="hljs-string">&quot;DUST&quot;</span> to Sky(<span class="hljs-string">&quot;浮尘&quot;</span>, <span class="hljs-keyword">R</span>.drawable.one_background,  <span class="hljs-keyword">R</span>.drawable.img)<br><br>    )<br>fun getSky(skycon:String):Sky&#123;<br>    return sky[skycon] ?:sky[<span class="hljs-string">&quot;CLEAR_DAY&quot;</span>]<span class="hljs-comment">!!</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>由于省事，我就没有给相应的天气设置相应的背景图和图标了，你有兴趣的话可以自己去找图片和图标添加，关于天气自定义图标添加可以去看我在csdn写的一篇博客☞<a href="https://blog.csdn.net/qq_60387902/article/details/126664727?spm=1001.2014.3001.5501">Android studio使用阿里巴巴图标矢量图库</a>！</p><h1 id="六、手动刷新天气和切换城市"><a href="#六、手动刷新天气和切换城市" class="headerlink" title="六、手动刷新天气和切换城市"></a>六、手动刷新天气和切换城市</h1><p>☀手动刷新天气简单，这里就不详细说了，使用一个SwipeRefreshLayout布局就行，详细步骤看我的项目demo，里面很详细。</p><p>🌙切换城市也是一个DrawerLayout布局的事情，也不细说了，看demo。需要注意的是，在侧滑菜单消失以后记得隐藏输入法，你可以试试不隐藏输入法时的效果，在DrawerLayout的监听里实现相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">drawerLayout.addDrawerListener(object :DrawerLayout.DrawerListener&#123;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerSlide</span><span class="hljs-params">(drawerView: View, slideOffset: Float)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerOpened</span><span class="hljs-params">(drawerView: View)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressLint(&quot;ServiceCast&quot;)</span><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerClosed</span><span class="hljs-params">(drawerView: View)</span> </span>&#123;<br>        <span class="hljs-comment">//因为弹出这个滑动菜单以后，如果想输入新的地址会弹出一个输入法，如果在你输完以后直接就关闭滑动菜单的话需要把输入法也关闭</span><br>        <span class="hljs-comment">//关闭弹出的输入法</span><br>        val manager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager<br>        manager.hideSoftInputFromWindow(drawerView.windowToken,InputMethodManager.HIDE_NOT_ALWAYS)<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onDrawerStateChanged</span><span class="hljs-params">(newState: Int)</span> </span>&#123;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最后一个阶段的开发任务也完成了，记得提交代码</p><p>🍓git add .         添加操作</p><p>🍓git commit -m “（这里可以描述你这次提交代码的简单说明，比如：新增切换城市和手动更新天气的功能）”</p><p>🍓git push origin main </p><h1 id="七、项目提升"><a href="#七、项目提升" class="headerlink" title="七、项目提升"></a>七、项目提升</h1><p>这个项目我是根据郭霖的《第一行代码》写的，我的demo过于简陋，很多能简单的就简单，以及一些ui可能你会觉得好丑或者什么，你可以自行修改；或者说你觉得天气显示的太少了或者不够精美不够详细，你也可以根据彩云天气的API自行修改……终于敲完了，好累好累好累！</p><p><img src="https://picgo-wei.oss-cn-shenzhen.aliyuncs.com/imgimg20220913205647.png"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
